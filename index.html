<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>all in one</title>
<script>

	//求2d向量夹角
	var angleVector2d = (a, b)=>{
	  let x1 = a[0],
	    y1 = a[1],
	    x2 = b[0],
	    y2 = b[1];
	  
	  let len1 = x1*x1 + y1*y1;
	  if (len1 > 0) {
	    len1 = 1 / Math.sqrt(len1);
	  }
	  
	  let len2 = x2*x2 + y2*y2;
	  if (len2 > 0) {
	    len2 = 1 / Math.sqrt(len2);
	  }
	  
	  let cosine = (x1 * x2 + y1 * y2) * len1 * len2;
	  
	  
	  if(cosine > 1.0) {
	    return 0;
	  }
	  else if(cosine < -1.0) {
	    return Math.PI;
	  } else {
	    return Math.acos(cosine);
	  }
	}
</script>
<meta name="keywords" content="">
<link hdomRef="" rel="stylesheet">
<style>
	.svg svg, .svg line:hover , .svg path:hover, .svg polygon:hover, .svg rect:hover, .svg circle:hover, .svg ellipse:hover{
		pointer-events: all;
	}
</style>
</head>
<body>
	<div style="position:absolute;left:0;top:0;z-index: 100">
		<button id="small" >small</button>
		<button id="middle" >middle</button>
		<button id="large" >large</button>
		<button id="red" >red</button>
		<button id="yellow" >yellow</button>
		<button id="blue" >blue</button>
		<button id="green" >green</button>
		<button id="black" >black</button>
		<button id="white" >white</button>
		<button id="arrow" >箭头</button>
		<button id="rectangle" >矩形</button>
		<button id="ellipse" >椭圆</button>
		<button id="path" >画笔</button>
		<button id="text" >文本</button>
		<button id="clear" >清空</button>
	</div>
    <div class="svg" style="width:600px; height:600px;border:1px solid #333; position: relative;">
    	<svg pointer-events="painted" width="600" height="600" id="svg" style="position:absolute; left:0px; top:0px;">
    		<g id="ggg" pointer-events="inherit">
    		</g>

    	</svg>
    	<div style="position: absolute;left:0;top:0; width:100%; height:100%; pointer-events:none;" class="svg-hover"></div>
    	<div style="width:100%;height:1px;left:0; top:50%;background: #333;position: absolute; pointer-events: none"></div>
    	<div style="width:1px;height:100%;left:50%; top:0%;background: #333;position: absolute; pointer-events: none"></div>
    </div>

</body>
</html>
<script>
	let svg = document.querySelector('#svg');
	let svgg = svg.querySelector('g');



	//边框大小
	const BorderSize = {
		small:2,
		middle:4,
		large:6
	}

	//箭头大小
	const ArrowSize = {
		small:8,
		middle:10,
		large:12
	}

	//字体大小
	const FontSize = {
		small:12,
		middle:14,
		large:16
	}
	
	//颜色
	const Color = {
		red:[255, 15, 0, 1],
		yellow:[255, 190, 0, 1],
		blue:[26, 155, 255, 1],
		green:[26, 173, 25, 1],
		black:[77, 77, 77, 1],
		white:[255, 255, 255, 1],
	}

	class CreateTag{
		constructor(tag, attrs){
			if(['path', 'line', 'ellipse', 'circle', 'rect', 'polygon', 'polyline', 'text'].includes(tag)){
				this.tag = document.createElementNS('http://www.w3.org/2000/svg', tag);
			}else{
				this.tag = document.createElement(tag);
			}
			
			this.attrs = attrs;
			this.setAttrs(attrs);
		}

		/**
		 * 设置属性对象
		 * @param {Object} attrs 属性名
		 */
		setAttrs(attrs){
			for(let attr in attrs){
				if(attr == 'style' && attrs[attr] instanceof Object){
					for(let _attr in attrs[attr]){
						this.tag.style[_attr] = attrs[attr][_attr];
					}
					continue;
				}
				
				
				//矩形
				if(attr == 'rectTranslate' || attr == 'ellipseTranslate' || attr == 'pathTranslate' || attr == 'textTranslate'){
					
					this.tag.setAttribute('transform', `translate(${attrs[attr].join(' ').toString()})`);	
					continue;
				}
				

				
				//箭头
				if(attr == 'domRef' || attr == 'polygon') continue;

				// if(attr == 'arrowOrigin'){
				// 	this.tag.setAttribute('transform-box', 'fill-box');
				// 	this.tag.setAttribute('transform-origin', `${attrs[attr][0]} ${attrs[attr][1]}px`);
				// 	continue;
				// }
				if(attr == 'points'){
					this.tag.setAttribute(attr, attrs[attr].join(' ').toString());	
					continue;
				}
				if(attr == 'worldTranslate' || attr == 'arrowTranslate' || attr == 'arrowRightRotate' || attr == 'arrowLeftRotate'){
					let _attrs = `translate(${attrs.worldTranslate.toString()}) translate(${attrs.arrowTranslate.toString()}) rotate(${attrs.arrowRightRotate}, ${0}, ${10}) rotate(${attrs.arrowLeftRotate}, ${attrs.width}, ${10})`;
					this.tag.setAttribute('transform', _attrs);
					continue;
				}
				if((attr == 'width' || attr == 'height') && attrs[attr] < 0 ) continue;
				this.tag.setAttribute(attr, attrs[attr]);
	        }
		}
	}


	class AnnotationFactory{
		constructor(viewer){
			this.viewer = viewer;

			this.shift = false;
		}

		//阻挡右键默认菜单
		preventDefault(obj){
			if(obj) {
				obj.oncontextmenu = (e)=>{e.preventDefault()} 
				return false;
			}
			this.viewer.oncontextmenu = (e)=>{e.preventDefault()}
		}

		//shift绑定
		bindShiftEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 16){
					this.shift = true;
				}
			});
			document.addEventListener('keyup', e=>{
				if(e.which == 16){
					this.shift = false;
				}
			});
		}
	}


	
	//图形管理类
	class AnnotationManager {
		constructor(viewer){
			this.annotations = [];
			this._currentAnnotation = null;
			this.isDrawing = false;

			this.viewer = viewer;
			
			//工具集合
			this.arrow = null;
			this.rectangle = null;
			this.ellipse = null;
			this.path = null;
			this.text = null;
		}

		clear(){
			for(let annotation of this.annotations){
				let idx = this.annotations.indexOf(annotation);
				if(idx == -1) return false;
				annotation.domRef && annotation.domRef.remove();

				annotation.drapMaskRef && annotation.drapMaskRef.remove();
				annotation = null;
			}
			this.isDrawing = false;
			this.annotations = [];
		}
		
		/**
		 * 删除指定注释
		 * @param  {AnnotationFactory} annotation [description]
		 */
		delete(annotation){
			let idx = this.annotations.indexOf(annotation);
			if(idx == -1) return false;
			annotation.domRef && annotation.domRef.remove();
			annotation.drapMaskRef && (annotation.drapMaskRef.innerHTML = '') && annotation.drapMaskRef.remove();
			this.annotations.splice(idx, 1);
			annotation = null;
			this.isDrawing = false;
		}

		get currentAnnotation(){
			return this._currentAnnotation;
		}
		set currentAnnotation(_annotation){
			for(let annotation of this.annotations){
				this.isDrawing = false;

				//恢复原始状态
				annotation.canDrap = false;
				annotation['pointer-events'] = 'all';
				annotation.svgRef.setAttrs(annotation);
				annotation.drapMaskRef && (annotation.drapMaskRef.style.display='none');
				annotation.domRef.style = annotation.style;
			}
			if(!!_annotation){
				_annotation.canDrap = true;
			}
			this._currentAnnotation = _annotation;
			if(this.annotations.indexOf(_annotation) == -1) this.annotations.push(_annotation);
		}
		
		//创建工具
		createAnnotationTools(){
			this.arrow = new Arrow(this.viewer, this);
			this.rectangle = new Rectangle(this.viewer, this);
			this.ellipse = new Ellipse(this.viewer, this);
			this.path = new Path(this.viewer, this);
			this.text = new Text(this.viewer, this);
		}
		
		//设置大小
		setSize(size){
			this.arrow.setSize(ArrowSize[size]);
			this.rectangle.setSize(BordeSize[size]);
			this.ellipse.setSize(BordeSize[size]);
			this.path.setSize(BordeSize[size]);
			this.text.setSize(FontSize[size]);
		}
		
		//设置颜色
		setColor(color){
			this.arrow.setSize(Color[size]);
			this.rectangle.setSize(Color[size]);
			this.ellipse.setSize(Color[size]);
			this.path.setSize(Color[size]);
			this.text.setSize(Color[size]);
		}
	}
	


	//事件控制类
	class EventController{
		constructor(viewer, annotationManager){
			this.viewer = viewer;
			this.annotationManager = annotationManager;

			//保存引用
			this.__bindMouseDownEvent = this._bindMouseDownEvent.bind(this);

			//状态
			this._isRunning = false;
			
		}

		get isRunning(){
			return this._isRunning;
		}
		
		_bindMouseDownEvent(e){
			if(e.which !=1 ) return false;
			if(this.annotationManager.isDrawing) return;
			this.annotationManager.isDrawing = true;
			this.bindMouseDownEvent && this.bindMouseDownEvent(e);

			
			let bindMouseMoveEvent = (e)=>{
				if(e.which !=1 ) return false;
				if(!this.annotationManager.isDrawing) return;
				this.bindMouseMoveEvent && this.bindMouseMoveEvent(e);
			}

			let bindMouseUpEvent = (e)=>{
				if(e.which !=1 ) return false;
				this.annotationManager.isDrawing = false;
				this.bindMouseUpEvent && this.bindMouseUpEvent(e);

				document.removeEventListener('mousemove', bindMouseMoveEvent);
				document.removeEventListener('mouseup', bindMouseUpEvent);
			}
			
			document.addEventListener('mousemove', bindMouseMoveEvent);
			document.addEventListener('mouseup', bindMouseUpEvent);
		}
		bindMouseDownEvent(e){}
		bindMouseMoveEvent(e){}
		bindMouseUpEvent(e){}

		
		//开始
		start(){
			this._isRunning = true;
			this.viewer.addEventListener('mousedown', this.__bindMouseDownEvent);
		}
		
		//结束
		stop(){
			this._isRunning = false;
			this.viewer.removeEventListener('mousedown', this.__bindMouseDownEvent);
		}
	}


	class TextFactory extends AnnotationFactory{
		constructor(annotationProps, annotationManager){
			super(annotationManager.viewer);
			this.name = 'text';
			this.texts = annotationProps.texts;
			this.annotationManager = annotationManager;
			this.x = annotationProps.x || annotationProps.left || 0;
			this.y = annotationProps.y || annotationProps.top || 0;
			this.width = annotationProps.width;
			this.height = annotationProps.height;
			this.fill = annotationProps.fill || annotationProps.color || 'red';
			this.lineHeight = annotationProps.lineHeight;
			this.hoverFill = annotationProps.hoverFill || annotationProps.hoverColor || 'green';
			this.fontSize = annotationProps.fontSize;
			this['font-size'] = this.fontSize || 16;
			this.textTranslate = annotationProps.textTranslate;
			this.viewer = annotationManager.viewer;

			this._style = annotationProps._style; 


			this.svgRef =null;
			this.domRef =null;

			
			this.drapMaskRef = null;
			
			//编辑文本和临时span
			this.textRef = null;
			this.spanRef = null;

			this.canDrap = false;
			this.isWriting = false;

			this.create();

		}

		create(){
			
			this.svgRef = new CreateTag('text', this);
			this.domRef = this.svgRef.tag;
			this.updateText();

			this.viewer.querySelector('g').appendChild(this.svgRef.tag);


			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();

			this.annotationManager.currentAnnotation = this;
		}
		
		//更新svg文本
		updateText(){
			let tspan = '';
			for(let i=0; i< this.texts.length; i++){
				tspan+=`\n<tspan x="${this.x+this.textTranslate[0]}" y="${this.y+this.textTranslate[1]+i*this.fontSize*1.1+this.fontSize}">${this.texts[i]}</tspan>`;
			}
			this.domRef.innerHTML = tspan;		
		}


		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.setAttribute('fill', this.hoverFill);

			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.setAttribute('fill', this.fill);
			}
		}

		//绑定事件
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.annotationManager.currentAnnotation = this;
				this.annotationManager.isDrawing = true;
				this.createDrapMask();
				this.viewer.parentNode.style.userSelect = 'none';
				e.stopPropagation();

				this.viewer.parentNode.style.userSelect = 'none';
			});
		}
		
		//样式
		createStyle(){
			let style = {};
			let { lineHeight, left, top, fill, fontSize, textTranslate, x, y } = this;
			let { width, height } = this.domRef.getBBox();
			style.transform = `translate(${textTranslate[0]}px, ${textTranslate[1]}px)`;
			style.height = height+'px';
			style.width = width+'px';
			style.lineHeight = lineHeight;
			style.left = x+'px';
			style.top = y+'px';
			style.fontSize = fontSize+'px';
			style.color = fill;
			style.position = 'absolute';
			style.outline = 'none';
			style.resize = 'none';
			style.padding = 0;
			style.overflowY = 'hidden';
			style.border = '1px solid red';
			style.fontFamily = 'Arial';
			style.wrap = "hard";
			return {style};
		}
		
		//双击编辑
		bindDoubleClickEvent(){
			if(!!this.annotation && this.annotation.isWriting) return;
			this.isWriting = true;
			
			this.spanRef = new CreateTag('span', {style:{whiteSpace:'nowrap', visibility:'hidden', fontSize:this.fontSize+'px', border:'1px solid red', fontFamily:'Arial'}}).tag;
			this.textRef = new CreateTag('textarea', this.createStyle()).tag;

			this.textRef.value = this.texts.join(' ');
			this.viewer.parentNode.appendChild(this.textRef);
			this.viewer.parentNode.appendChild(this.spanRef);

			this.textRef.focus();

			this.svgRef.setAttrs({visibility:'hidden'});
			this.drapMaskRef.style.visibility = 'hidden';
			this.preventDefault(this.textRef);
			
			this.bindTextChangEvent();
		}

		//添加控制遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);
			
			this['pointer-events'] = 'none';
			this.svgRef.setAttrs(this);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//绑定拖拽事件
			this.bindDrapEvent();


			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));
			this.drapMaskRef.ondblclick = this.bindDoubleClickEvent.bind(this);

			this.preventDefault(this.drapMaskRef);
		}


		//输入事件
		bindTextChangEvent(){
			this.textRef.oninput = e=>{
				let value =  e.target.value;
				let text = '';
				this.spanRef.innerHTML = '';
				for(let i=0; i< value.length; i++){
					let val = value.charAt(i);
					val == ' ' && (val = '');
					this.spanRef.innerHTML += val;
					if(this.spanRef.offsetWidth > this.textRef.offsetWidth+6){
						text += '\#';
						text += val;
						this.spanRef.innerHTML = '';
					}else{
						text += val;
					}
				}

				this.texts= text.split('\#');
			}
		}

		//更新遮罩位置
		updateDrapMask(pointerEvents){
			let {x, y} = this;
			let { width, height } = this.domRef.getBBox();
			let styleObj = {
				position:'absolute',
				left:x + this.textTranslate[0] + 'px',
				top:y + this.textTranslate[1] + 'px',
				zIndex:100,
				width: width + 'px',
				height:height + 'px',
				display:'block',
				cursor:'move',
				border:'1px solid red',
				boxSizing:'border-box',
				pointerEvents:pointerEvents,
				transform:`translate(${this.textTranslate[0]}px, ${this.textTranslate[1]}px)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}


		//方向调整
		bindDirectionEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 37){
					this.textTranslate[0] -= 1;
					this.updateAll();
				}
				if(e.which == 38){
					this.textTranslate[1] -= 1;
					this.updateAll();
				}
				if(e.which == 39){
					this.textTranslate[0] += 1;
					this.updateAll();
				}
				if(e.which == 40){
					this.textTranslate[1] += 1;
					this.updateAll();
				}
				
			});
		}

		//移动事件绑定
		bindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.textTranslate[0]+disx}px, ${this.textTranslate[1]+disy}px)`;
					this.textTranslate = [this.textTranslate[0]+disx, this.textTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					this.updateAll();
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
		}

		//更新原点，偏移清0
		updateAll(){

			this.x += this.textTranslate[0];
			this.y += this.textTranslate[1];
			this.textTranslate[0] = this.textTranslate[1] = 0;

			this.svgRef.setAttrs(this);
			this.updateDrapMask();
			this.updateText();
		}

		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.annotationManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;
			this.viewer.parentNode.style.userSelect = 'initial';


			this.svgRef.setAttrs({visibility:'visible'});
			this.textRef && this.textRef.remove();
			this.spanRef && this.spanRef.remove();
			this.updateText();
			
			this.textRef = null;
			this.spanRef = null;
			if(!this.texts || (this.texts.length == 1 && !this.texts[0])){
				this.annotationManager.annotations.splice(this.annotationManager.annotations.indexOf(this), 1);
				this.domRef.remove();
				this.domRef = null;
				this.svgRef = null;
			}
		}
	}
	
	//文本类
	class Text extends EventController{
		constructor(viewer, annotationManager){
			super(viewer, annotationManager);
			this.name = 'text';
			
			this.size = FontSize.middle;
			this.color = Color.red;

			this.initData = null;
			this.annotationManager = annotationManager;
			this.annotation = null;
			this.preventDefault();
		}
		

		createAttrs(){

			let _color = this.color;
			let _hoverColor = JSON.parse(JSON.stringify(this.color));
			_hoverColor[3] = 0.8;
			this.initData = {
				viewer:this.viewer,
				texts:[],
				textTranslate:[0, 0],
				color:'rgba('+_color.toString()+')',
				fontSize:this.size,
				hoverColor:'rgba('+_hoverColor.toString()+')',
				lineHeight:'16px',
				left:0,
				padding:0,
				top:0,
				width:200,
				height:50,
				style:'',
				isWriting:false
			}
			this.initData.textTranslate = JSON.parse(JSON.stringify(this.initData.textTranslate));
			this.initData.texts = JSON.parse(JSON.stringify(this.initData.texts));
			return {...this.initData};
		}
		
		/**
		 * 设置边框大小
		 * @param {BorderSize} size
		 */
		setSize(size){
			this.size = FontSize[size];
		}

		/**
		 * 设置颜色
		 * @param {Color} color 
		 */
		setColor(color){
			this.color = Color[color];
		}


		createStyle(styleObj){
			let style = {};
			let { height, width, lineHeight, left, top, color, fontSize, textTranslate } = styleObj;
			// style.transform = `translate(${textTranslate[0]}px, ${textTranslate[1]}px)`;
			style.height = height+'px';
			style.width = width+'px';
			style.lineHeight = lineHeight;
			style.left = left+'px';
			style.top = top+'px';
			style.fontSize = fontSize+'px';
			style.color = color;
			style.position = 'absolute';
			style.outline = 'none';
			style.resize = 'none';
			style.padding = 0;
			style.overflowY = 'hidden';
			style.border = '1px solid red';
			style.fontFamily = 'Arial';
			style.wrap = "hard";
			this.annotation._style = style;
			return {style};
		}

		//阻挡右键默认菜单
		preventDefault(obj){
			if(obj) {
				obj.oncontextmenu = (e)=>{e.preventDefault()} 
				return false;
			}
			document.querySelector('svg').oncontextmenu = (e)=>{e.preventDefault()}
		}

		bindMouseDownEvent(e){
			if(!!this.annotation && this.annotation.isWriting) return;
			let x = e.offsetX;
			let y = e.offsetY;
			this.annotation = this.createAttrs();
			this.annotation.left = x;
			this.annotation.top = y;
			this.annotation.isWriting = true;
			
			this.annotation.spanRef = new CreateTag('span', {style:{whiteSpace:'nowrap', visibility:'hidden', fontSize:this.annotation.fontSize+'px', border:'1px solid red', fontFamily:'Arial'}}).tag;

			this.annotation.svgRef = new CreateTag('textarea', this.createStyle({...this.annotation}));
			this.annotation.domRef = this.annotation.svgRef.tag;
			this.viewer.parentNode.appendChild(this.annotation.domRef);
			this.viewer.parentNode.appendChild(this.annotation.spanRef);


			this.preventDefault(this.annotation.domRef);
			this.bindTextChangEvent();
			this.bindRightClickEvent();
		}

		//输入事件
		bindTextChangEvent(){
			this.annotation.domRef.oninput = e=>{
				let value =  e.target.value;
				let text = '';
				this.annotation.spanRef.innerHTML = '';
				for(let i=0; i< value.length; i++){
					let val = value.charAt(i);
					val == ' ' && (val = '\s');
					this.annotation.spanRef.innerHTML += val;
					if(this.annotation.spanRef.offsetWidth > this.annotation.width+6){
						text += '\#';
						text += val;
						this.annotation.spanRef.innerHTML = '';
					}else{
						text += val;
					}
				}
				this.annotation.texts= text.split('\#');
			}
		}

		//右键结束
		bindRightClickEvent(){
			let rightClick = e=>{
				if(e.which != 3) return;
				if(!this.annotation.domRef) return false;
				this.annotation.isWriting = false;
				this.annotationManager.isDrawing = false;
				
				this.annotation.domRef.remove();
				this.annotation.domRef = null;
				this.annotation.svgRef = null;

				if(this.annotation.texts.length < 1 ) return;
				let annotation = new TextFactory({...this.annotation}, this.annotationManager);
				document.removeEventListener('mousedown', rightClick);
			}
			document.addEventListener('mousedown', rightClick);
		}

	}

	//路径创建类
	class PathFactory extends AnnotationFactory{
		constructor(annotationProps, annotationManage){
			super(annotationManage.viewer);
			this.name = 'path';
			this.viewer = annotationManager.viewer;
			this.style = annotationProps.style;
			this.hoverStyle = annotationProps.hoverStyle;
			this.originx = annotationProps.originx;
			this.originy = annotationProps.originy;
			this.pathTranslate = annotationProps.pathTranslate;
			this.d = annotationProps.d;
			this.svgRef =null;
			this.domRef =null;
			this.drapMaskRef = null;
			this.canDrap = false;
			this['pointer-events'] = annotationProps['pointer-events'];
			
			this.annotationManager = annotationManager;

			this.create();
		}

		create(){
			this.svgRef = new CreateTag('path', this);
			this.domRef = this.svgRef.tag;
			this.viewer.querySelector('g').appendChild(this.svgRef.tag);
			
			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();

			this.annotationManager.currentAnnotation = this;
		}

		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.style = this.hoverStyle;

			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.style = this.style;
			}
		}

		//绑定事件
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.annotationManager.currentAnnotation = this;
				this.annotationManager.isDrawing = true;
				this.createDrapMask();
				e.stopPropagation();

				this.viewer.parentNode.style.userSelect = 'none';
			});
		}

		//添加控制遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);
			
			this['pointer-events'] = 'none';
			this.svgRef.setAttrs(this);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//绑定拖拽事件
			this.bindDrapEvent();

			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));
			this.preventDefault(this.drapMaskRef);
		}

		//更新遮罩位置
		updateDrapMask(pointerEvents){
			let {x, y, width, height} = this.domRef.getBBox();
			let styleObj = {
				position:'absolute',
				left:x +'px',
				top:y +'px',
				zIndex:100,
				width: width + 'px',
				height:height + 'px',
				display:'block',
				cursor:'move',
				border:'1px solid red',
				boxSizing:'border-box',
				pointerEvents:pointerEvents,
				transform:`translate(${this.pathTranslate[0]}px, ${this.pathTranslate[1]}px)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}


		//方向调整
		bindDirectionEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 37){
					this.pathTranslate[0] -= 1;
					this.updateAll();
				}
				if(e.which == 38){
					this.pathTranslate[1] -= 1;
					this.updateAll();
				}
				if(e.which == 39){
					this.pathTranslate[0] += 1;
					this.updateAll();
				}
				if(e.which == 40){
					this.pathTranslate[1] += 1;
					this.updateAll();
				}
				
			});
		}

		//移动事件绑定
		bindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.pathTranslate[0]+disx}px, ${this.pathTranslate[1]+disy}px)`;
					this.pathTranslate = [this.pathTranslate[0]+disx, this.pathTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					this.updateAll();
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
		}

		//更新原点，偏移清0
		updateAll(){
			this.svgRef.setAttrs(this);
			this.updateDrapMask();
		}



		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.annotationManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;

			this.viewer.parentNode.style.userSelect = 'initial';
		}
	}


	//路径类
	class Path extends EventController{
		constructor(viewer, annotationManager){
			super(viewer, annotationManager);
			this.name = 'path';
			this.viewer = viewer;
			this.annotationManager = annotationManager;
			

			this.lastx = 0;
			this.lasty = 0;
			
			this.size = BorderSize.middle;
			this.color = Color.red;

			this.initData = null;
			this.annotation = null;
			
		}

		/**
		 * 设置边框大小
		 * @param {BorderSize} size
		 */
		setSize(size){
			this.size = BorderSize[size];
		}

		/**
		 * 设置颜色
		 * @param {Color} color 
		 */
		setColor(color){
			this.color = Color[color];
		}

		createAttrs(){

			let _color = this.color;
			let _hoverColor = JSON.parse(JSON.stringify(this.color));
			_hoverColor[3] = 0.8;
			this.initData = {
				viewer:this.viewer,
				style:'stroke:rgba('+_color.toString()+'); fill:none; stroke-width:'+this.size,
				pathTranslate:[0, 0],
				pathScale:[1, 1],
				svgRef:null,
				domRef:null,
				shift:false,//左右直线
				ctrl:false,//上下直线
				canDrap:false,
				d:'',
				originx:0,
				originy:0,
				hoverStyle:'stroke:rgba('+_hoverColor.toString()+'); fill:none; stroke-width:'+this.size,
			
				'pointer-events':'all'
			}
			this.initData.pathTranslate = JSON.parse(JSON.stringify(this.initData.pathTranslate));
			this.initData.pathScale = JSON.parse(JSON.stringify(this.initData.pathScale));
			return {...this.initData};
		}

		//shift绑定
		bindShiftEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 16){
					this.annotation.shift = true;
				}
				if(e.which == 17){
					this.annotation.ctrl = true;
				}
			});
			document.addEventListener('keyup', e=>{
				if(e.which == 16){
					this.annotation.shift = false;
				}
				if(e.which == 17){
					this.annotation.ctrl = false;
				}
			});
		}

		bindMouseDownEvent(e){
			let x = e.offsetX;
			let y = e.offsetY;
			this.annotation = this.createAttrs();
			this.bindShiftEvent();
			this.annotation.originx = x;
			this.annotation.originy = y;
			this.lastx = x;
			this.lasty = y;
			this.annotation.d = `M${x} ${y}`;
		}

		bindMouseMoveEvent(e){
			let x = e.offsetX;
			let y = e.offsetY;

			//直线			
			if(this.annotation.shift && !this.annotation.ctrl){
				y = this.lasty;
			}

			if(!this.annotation.shift && this.annotation.ctrl){
				x = this.lastx;
			}


			this.annotation.d += this.annotation.d.includes('L') ? ` ${x} ${y}` : ` L${x} ${y}`;

			if(!this.annotation.svgRef){
				this.annotation.svgRef = new CreateTag('path', this.annotation);
				this.annotation.domRef = this.annotation.svgRef.tag;
				this.viewer.querySelector('g').appendChild(this.annotation.domRef);
			}

			this.lastx = x;
			this.lasty = y;
			this.annotation.svgRef && this.annotation.svgRef.setAttrs(this.annotation);
		}

		//抬起鼠标
		bindMouseUpEvent(){
			if(!this.annotation.svgRef) return false;
			this.annotation.domRef.remove();
			this.annotation.domRef = null;
			this.annotation.svgRef = null;
			let annotation = new PathFactory({...this.annotation}, this.annotationManager);
			this.annotationManager.currentAnnotation = annotation
		}
	}

	//椭圆创建类
	class EllipseFactory extends AnnotationFactory{
		constructor(annotationProps, annotationManage){
			super(annotationManage.viewer);
			this.name = 'ellipse';
			this.viewer = annotationManager.viewer;
			this.style = annotationProps.style;
			this.hoverStyle = annotationProps.hoverStyle;
			this.cx = annotationProps.cx;
			this.cy = annotationProps.cy;
			this.rx = annotationProps.rx;
			this.ry = annotationProps.ry;
			this.originx = annotationProps.originx;
			this.originy = annotationProps.originy;
			this.ellipseTranslate = annotationProps.ellipseTranslate;
			this.svgRef =null;
			this.domRef =null;
			this.drapMaskRef = null;
			this.canDrap = false;
			this.shift = annotationProps.shift;
			this['pointer-events'] = annotationProps['pointer-events'];
			
			this.annotationManager = annotationManager;

			this.controllerPoints = [];
			this.create();
		}

		create(){
			this.svgRef = new CreateTag('ellipse', this);
			this.domRef = this.svgRef.tag;
			this.viewer.querySelector('g').appendChild(this.svgRef.tag);
			
			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();
			this.bindShiftEvent();
			this.bindDirectionEvent();

			this.annotationManager.currentAnnotation = this;
		}

		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.style = this.hoverStyle;

			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.style = this.style;
			}
		}

		//绑定事件
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.annotationManager.currentAnnotation = this;
				this.annotationManager.isDrawing = true;
				this.createDrapMask();
				e.stopPropagation();

				this.viewer.parentNode.style.userSelect = 'none';
			});
		}

		//添加控制遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);
			
			this['pointer-events'] = 'none';
			this.svgRef.setAttrs(this);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//创建控制点
			this.createControllerPoints();
			
			//绑定拖拽事件
			this.bindDrapEvent();


			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));

			this.preventDefault(this.drapMaskRef);
		}

		//更新遮罩位置
		updateDrapMask(pointerEvents){

			let styleObj = {
				position:'absolute',
				left:this.cx - this.rx +'px',
				top:this.cy - this.ry +'px',
				zIndex:100,
				width: this.rx * 2 + 'px',
				height:this.ry * 2 + 'px',
				display:'block',
				cursor:'move',
				border:'1px solid red',
				boxSizing:'border-box',
				pointerEvents:pointerEvents,
				transform:`translate(${this.ellipseTranslate[0]}px, ${this.ellipseTranslate[1]}px)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}

		//创建控制点
		createControllerPoints(){

			/**
			 * 创建控制点
			 * @param  {String} options.left    左偏移
			 * @param  {String} options.top     上偏移
			 * @param  {String} options.cursor  鼠标类型
			 * @param  {String} options.align   位置，只做别名，无其他作用
			 * @param  {String} options.affects 影响范围，0-无影响，1-正相关， -1-负相关
			 */
			let createPoint = ({left, top, cursor, align, affects})=>{
				let point = document.createElement('a');
				point.style.href= 'javascript:;';
				point.style.width = point.style.height = '10px';
				point.style.border = '2px solid red';
				point.style.boxSizing = 'border-box';
				point.style.background = '#fff';
				point.style.borderRadius = '5px';
				point.style.cursor = cursor;
				point.style['pointer-events'] = 'all';
				point.style.position = 'absolute';
				point.style.left = left;
				point.style.top = top;
				point._align = align;
				point.affects= affects;
				return point;
			}
			
			let topLeftPoint = createPoint({left:'-5px', top:'-5px', cursor:'nwse-resize', align:'topLeft', affects:{cx:1, cy:1, rx:-1, ry:-1}});
			let topCenterPoint = createPoint({left:'calc(50% - 5px)', cursor:'s-resize', top:'-5px', align:'topCenter', affects:{cx:0, cy:1, rx:0, ry:-1}});
			let topRightPoint = createPoint({left:'calc(100% - 5px)', cursor:'nesw-resize', top:'-5px', align:'topRight', affects:{cx:1, cy:-1, rx:1, ry:-1}});
			let middleLeftPoint = createPoint({left:'-5px', top:'calc(50% - 5px)', cursor:'e-resize', align:'middleLeft', affects:{cx:1, cy:0, rx:-1, ry:0}});
			let middleRightPoint = createPoint({left:'calc(100% - 5px)', top:'calc(50% - 5px)', cursor:'w-resize', align:'middleRight', affects:{cx:1, cy:0, rx:1, ry:0}});
			let bottomLeftPoint = createPoint({left:'-5px', top:'calc(100% - 5px)', cursor:'nesw-resize', align:'bottomLeft', affects:{cx:1, cy:-1, rx:-1, ry:1}});
			let bottomCenterPoint = createPoint({left:'calc(50% - 5px)', top:'calc(100% - 5px)', cursor:'n-resize', align:'bottomCenter', affects:{cx:0, cy:1, rx:0, ry:1}});
			let bottomRightPoint = createPoint({left:'calc(100% - 5px)', top:'calc(100% - 5px)', cursor:'nwse-resize', align:'bottomRight', affects:{cx:1, cy:1, rx:1, ry:1}});
			topLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			topCenterPoint.oncontextmenu = (e)=>{e.preventDefault()}
			topRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			middleLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			middleRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomCenterPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			this.bindControllerPointEvent(topLeftPoint);
			this.bindControllerPointEvent(topCenterPoint);
			this.bindControllerPointEvent(topRightPoint);
			this.bindControllerPointEvent(middleLeftPoint);
			this.bindControllerPointEvent(middleRightPoint);
			this.bindControllerPointEvent(bottomLeftPoint);
			this.bindControllerPointEvent(bottomCenterPoint);
			this.bindControllerPointEvent(bottomRightPoint);
			this.drapMaskRef.appendChild(topLeftPoint);
			this.drapMaskRef.appendChild(topCenterPoint);
			this.drapMaskRef.appendChild(topRightPoint);
			this.drapMaskRef.appendChild(middleLeftPoint);
			this.drapMaskRef.appendChild(middleRightPoint);
			this.drapMaskRef.appendChild(bottomLeftPoint);
			this.drapMaskRef.appendChild(bottomCenterPoint);
			this.drapMaskRef.appendChild(bottomRightPoint);
			this.controllerPoints = [topLeftPoint, topRightPoint, middleLeftPoint, middleLeftPoint, bottomLeftPoint, bottomCenterPoint, bottomRightPoint];
		}
		
		//方向调整
		bindDirectionEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 37){
					this.ellipseTranslate[0] -= 1;
					this.updateAll();
				}
				if(e.which == 38){
					this.ellipseTranslate[1] -= 1;
					this.updateAll();
				}
				if(e.which == 39){
					this.ellipseTranslate[0] += 1;
					this.updateAll();
				}
				if(e.which == 40){
					this.ellipseTranslate[1] += 1;
					this.updateAll();
				}
				
			});
		}

		//给控制点绑定事件
		bindControllerPointEvent(point){
			let affects = point.affects;


			/*******************************/	
			/*   A          B           C
			/*	  ---------------------
			/*	  |					  |				
			/*	  |                   |
			/*	  |					  |
			/*  G |					  | D
			/*	  |					  |
			/*	  |					  |
			/*	  |					  |
			/*	  ---------------------
			/*  F		    D		    E 
			/*******************************/

			

			point.onmousedown = e=>{
				
				if(e.which !=1 || !this.annotationManager.isDrawing) return;
				
				//点击坐标
				let ox = e.clientX;
				let oy = e.clientY;

				//逆转此次数奇数为已经逆转，偶数为正常，
				let idx = 0;
				let idy = 0;
				
				//原点坐标，用于设置临界点
				let tox = this.cx - this.rx;
				let toy = this.cy - this.ry;

				//原点坐标，用于设置临界点
				let hox = this.cx + this.rx;
				let hoy = this.cy + this.ry;
				

				//等比缩放专用
				let originx = tox;
				let originy = toy;


				let mousemove = e=>{
					if(!this.canDrap) return;
					if(e.which != 1) return;
					e.stopPropagation();

					if(this.shift && point._align == 'bottomRight'){
						
						let x = e.clientX;
						let y = e.clientY;

					
						let absx = 0;
						let absy = 0;
						let abs = 0;


						absx = Math.abs(x - originx);
						absy = Math.abs(y - originy);
						abs = Math.max(absy, absx);

						//右边
						if(x > originx){

							//上
							if(y > originy){
								this.cx = originx + abs/2;
								this.cy = originy + abs/2;
							//下
							}else{
								this.cx = originx + abs/2;
								this.cy = originy - abs/2;
							}
						}

						//左边
						if(x < originx){
							//下边
							if(y > originy){
								this.cx = originx - abs/2;
								this.cy = originy + abs/2;

							//上边
							}else{
								this.cx = originx - abs/2;
								this.cy = originy - abs/2;
							}
						}


						this.rx = this.ry = abs/2;
						this.updateAll();
						return;
					}
					
					//差值
					let disx = e.clientX - ox;
					let disy = e.clientY - oy;
					ox = e.clientX;
					oy = e.clientY;

					if(affects.cx){
						this.cx += disx/2;

					}

					if(affects.rx){
						this.rx += affects.rx*disx/2;
					}
					
					if(affects.cy){
						this.cy += disy/2;
						
					}
					
					if(affects.ry){
						this.ry += affects.ry*disy/2;
					}


					//当负数时，启动逆转
					if(this.rx < 0){

						//向右
						if(disx > 0){

							//实际原点x
							if(idx != 0){
								
								this.cx = hox;
								this.rx = 0
							}else{
								this.cx = hox;

								//重新设置x边界
								tox = hox;
								this.rx = 0; 
							}

						//向左
						}else{
							this.cx = tox;

							//重新设置x边界
							hox = tox;
							this.rx = 0;
						}
						this.updateAll();
						idx++;
						affects.rx = -affects.rx;
						return;
					}


					if(this.ry < 0 ){
						
						//向下
						if(disy > 0){

							//实际原点y
							if(idy != 0){
								this.cy = hoy;
								this.ry = 0;
							}else{
								this.cy = hoy;

								toy = hoy;
								this.ry = 0;
								
							}

						//向上
						}else{
							this.cy = toy;

							hoy = toy;
							this.ry = 0;
						}
						this.updateAll();
						idy++;
						affects.ry = -affects.ry;
						return;
						
					}
					this.updateAll();
				}

				let mouseup = e=>{
					this.drapMaskRef.style['pointer-events'] = 'all';
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);

					//重新计算
					this.updateAll();
					this.canDrap = true;
				}
				
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
			
		}

		//更新控制点，一把梭
		updateControllerPoints(){
			for(let point of this.controllerPoints){
				point.remove();
			}
			this.createControllerPoints();
		}

		//移动事件绑定
		bindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.ellipseTranslate[0]+disx}px, ${this.ellipseTranslate[1]+disy}px)`;
					this.ellipseTranslate = [this.ellipseTranslate[0]+disx, this.ellipseTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					this.updateAll();
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
		}

		//更新原点，偏移清0
		updateAll(){
			this.cx += this.ellipseTranslate[0];
			this.cy += this.ellipseTranslate[1];
			this.ellipseTranslate[0] = this.ellipseTranslate[1] = 0;
			this.svgRef.setAttrs(this);
			this.updateDrapMask();
			this.updateControllerPoints();
		}



		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.annotationManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;

			this.viewer.parentNode.style.userSelect = 'initial';
		}
	}


	//椭圆类
	class Ellipse extends EventController{
		constructor(viewer, annotationManager){
			super(viewer, annotationManager);
			this.name = 'ellipse';
			this.viewer = viewer;
			this.annotationManager = annotationManager;

			this.size = BorderSize.middle;
			this.color = Color.red;

			this.initData = null;
			this.annotation = null;
			
		}

		createAttrs(){

			let _color = this.color;
			let _hoverColor = JSON.parse(JSON.stringify(this.color));
			_hoverColor[3] = 0.8;
			this.initData = {
				viewer:this.viewer,
				style:'stroke:rgba('+_color.toString()+'); fill:none; stroke-width:'+this.size,
				ellipseTranslate:[0, 0],
				svgRef:null,
				domRef:null,
				shift:false,
				canDrap:false,
				hoverStyle:'stroke:rgba('+_hoverColor.toString()+'); fill:none; stroke-width:'+this.size,
				cx:0,
				cy:0,
				rx:0,
				ry:0,
				originx:0,
				originy:0,
				'pointer-events':'all'
			}
			this.initData.ellipseTranslate = JSON.parse(JSON.stringify(this.initData.ellipseTranslate))
			return {...this.initData};
		}

		/**
		 * 设置边框大小
		 * @param {BorderSize} size
		 */
		setSize(size){
			this.size = BorderSize[size];
		}

		/**
		 * 设置颜色
		 * @param {Color} color 
		 */
		setColor(color){
			this.color = Color[color];
		}

		//shift绑定
		bindShiftEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 16){
					this.annotation.shift = true;
				}
			});
			document.addEventListener('keyup', e=>{
				if(e.which == 16){
					this.annotation.shift = false;
				}
			});
		}

		bindMouseDownEvent(e){
			this.annotation = this.createAttrs();
			this.bindShiftEvent();
			let x = e.clientX;
			let y = e.clientY;
			this.annotation.cx = x;
			this.annotation.cy = y;
			this.annotation.originx = x;
			this.annotation.originy = y;
			
		}

		bindMouseMoveEvent(e){
			let x = e.clientX;
			let y = e.clientY;


			/*
					y1 > y0
					|
					|  
					|
	    	--------|--------- x1 > x0
					|  
					|
					|
			*/
		
			let absx = 0;
			let absy = 0;
			let abs = 0;

			absx = Math.abs(x - this.annotation.originx);
			absy = Math.abs(y - this.annotation.originy);
			abs = Math.max(absy, absx);
			if(this.annotation.shift) absx = absy = abs;

			//右边
			if(x > this.annotation.originx){

				//上
				if(y > this.annotation.originy){
					this.annotation.cx = this.annotation.originx + absx/2;
					this.annotation.cy = this.annotation.originy + absy/2;
				//下
				}else{
					this.annotation.cx = this.annotation.originx + absx/2;
					this.annotation.cy = this.annotation.originy - absy/2;
				}
			}

			//左边
			if(x < this.annotation.originx){
				//下边
				if(y > this.annotation.originy){
					this.annotation.cx = this.annotation.originx - absx/2;
					this.annotation.cy = this.annotation.originy + absy/2;

				//上边
				}else{
					this.annotation.cx = this.annotation.originx - absx/2;
					this.annotation.cy = this.annotation.originy - absy/2;
				}
			}

			if(absx > 4 && absy > 4 && !this.annotation.svgRef){
				this.annotation.svgRef = new CreateTag('ellipse', this.annotation);
				this.annotation.domRef = this.annotation.svgRef.tag;
				this.viewer.appendChild(this.annotation.domRef);
			}

			this.annotation.rx = absx/2;
			this.annotation.ry = absy/2;
			this.annotation.svgRef && this.annotation.svgRef.setAttrs(this.annotation);
		}


		//抬起鼠标
		bindMouseUpEvent(){
			if(!this.annotation.svgRef) return false;
			this.annotation.domRef.remove();
			this.annotation.domRef = null;
			this.annotation.svgRef = null;
			let annotation = new EllipseFactory({...this.annotation}, this.annotationManager);
			this.annotationManager.currentAnnotation = annotation
		}
	}

	class RectangleFactory extends AnnotationFactory{
		constructor(annotationProps, annotationManager){
			super(annotationManager.viewer);
			this.name = 'rectangle';
			this.viewer = annotationManager.viewer;
			this.style = annotationProps.style;
			this.hoverStyle = annotationProps.hoverStyle;
			this.x = annotationProps.x;
			this.y = annotationProps.y;
			this.originx = annotationProps.originx;
			this.originy = annotationProps.originy;
			this.width = annotationProps.width;
			this.height = annotationProps.height;
			this.rectTranslate = annotationProps.rectTranslate;
			this.svgRef =null;
			this.domRef =null;
			this.drapMaskRef = null;
			this.canDrap = false;
			this.shift = annotationProps.shift;
			this['pointer-events'] = annotationProps['pointer-events'];
			
			this.annotationManager = annotationManager;

			this.controllerPoints = [];
			this.create();
		}

		create(){
			this.svgRef = new CreateTag('rect', this);
			this.domRef = this.svgRef.tag;
			this.viewer.querySelector('g').appendChild(this.svgRef.tag);
			
			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();
			this.bindShiftEvent();
			this.bindDirectionEvent();

			this.annotationManager.currentAnnotation = this;
		}

		

		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.style = this.hoverStyle;

			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.style = this.style;
			}
		}

		//绑定事件
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.annotationManager.currentAnnotation = this;
				this.annotationManager.isDrawing = true;
				this.createDrapMask();
				e.stopPropagation();

				this.viewer.parentNode.style.userSelect = 'none';
			});
		}

		//方向调整
		bindDirectionEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 37){
					this.rectTranslate[0] -= 1;
					this.updateAll();
				}
				if(e.which == 38){
					this.rectTranslate[1] -= 1;
					this.updateAll();
				}
				if(e.which == 39){
					this.rectTranslate[0] += 1;
					this.updateAll();
				}
				if(e.which == 40){
					this.rectTranslate[1] += 1;
					this.updateAll();
				}
				
			});
		}
		
		//更新控制点，一把梭
		updateControllerPoints(){
			for(let point of this.controllerPoints){
				point.remove();
			}
			this.createControllerPoints();
		}

		//创建控制点
		createControllerPoints(){

			/**
			 * 创建控制点
			 * @param  {String} options.left    左偏移
			 * @param  {String} options.top     上偏移
			 * @param  {String} options.cursor  鼠标类型
			 * @param  {String} options.align   位置，只做别名，无其他作用
			 * @param  {String} options.affects 影响范围，0-无影响，1-正相关， -1-负相关
			 * @return {String}                 [description]
			 */
			let createPoint = ({left, top, cursor, align, affects})=>{
				let point = document.createElement('a');
				point.style.href= 'javascript:;';
				point.style.width = point.style.height = '10px';
				point.style.border = '2px solid red';
				point.style.boxSizing = 'border-box';
				point.style.background = '#fff';
				point.style.borderRadius = '5px';
				point.style.cursor = cursor;
				point.style['pointer-events'] = 'all';
				point.style.position = 'absolute';
				point.style.left = left;
				point.style.top = top;
				point._align = align;
				point.affects= affects;
				return point;
			}
			
			let topLeftPoint = createPoint({left:'-5px', top:'-5px', cursor:'nwse-resize', align:'topLeft', affects:{x:1, y:1, width:-1, height:-1}});
			let topCenterPoint = createPoint({left:'calc(50% - 5px)', cursor:'s-resize', top:'-5px', align:'topCenter', affects:{x:0, y:1, width:0, height:-1}});
			let topRightPoint = createPoint({left:'calc(100% - 5px)', cursor:'nesw-resize', top:'-5px', align:'topRight', affects:{x:0, y:1, width:1, height:-1}});
			let middleLeftPoint = createPoint({left:'-5px', top:'calc(50% - 5px)', cursor:'e-resize', align:'middleLeft', affects:{x:1, y:0, width:-1, height:0}});
			let middleRightPoint = createPoint({left:'calc(100% - 5px)', top:'calc(50% - 5px)', cursor:'w-resize', align:'middleRight', affects:{x:0, y:0, width:1, height:0}});
			let bottomLeftPoint = createPoint({left:'-5px', top:'calc(100% - 5px)', cursor:'nesw-resize', align:'bottomLeft', affects:{x:1, y:0, width:-1, height:1}});
			let bottomCenterPoint = createPoint({left:'calc(50% - 5px)', top:'calc(100% - 5px)', cursor:'n-resize', align:'bottomCenter', affects:{x:0, y:0, width:0, height:1}});
			let bottomRightPoint = createPoint({left:'calc(100% - 5px)', top:'calc(100% - 5px)', cursor:'nwse-resize', align:'bottomRight', affects:{x:0, y:0, width:1, height:1}});
			topLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			topCenterPoint.oncontextmenu = (e)=>{e.preventDefault()}
			topRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			middleLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			middleRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomCenterPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			this.bindControllerPointEvent(topLeftPoint);
			this.bindControllerPointEvent(topCenterPoint);
			this.bindControllerPointEvent(topRightPoint);
			this.bindControllerPointEvent(middleLeftPoint);
			this.bindControllerPointEvent(middleRightPoint);
			this.bindControllerPointEvent(bottomLeftPoint);
			this.bindControllerPointEvent(bottomCenterPoint);
			this.bindControllerPointEvent(bottomRightPoint);
			this.drapMaskRef.appendChild(topLeftPoint);
			this.drapMaskRef.appendChild(topCenterPoint);
			this.drapMaskRef.appendChild(topRightPoint);
			this.drapMaskRef.appendChild(middleLeftPoint);
			this.drapMaskRef.appendChild(middleRightPoint);
			this.drapMaskRef.appendChild(bottomLeftPoint);
			this.drapMaskRef.appendChild(bottomCenterPoint);
			this.drapMaskRef.appendChild(bottomRightPoint);
			this.controllerPoints = [topLeftPoint, topRightPoint, middleLeftPoint, middleLeftPoint, bottomLeftPoint, bottomCenterPoint, bottomRightPoint];
		}

		//给控制点绑定事件
		bindControllerPointEvent(point){

			let affects = point.affects;


			/*******************************/	
			/*   A          B           C
			/*	  ---------------------
			/*	  |					  |				
			/*	  |                   |
			/*	  |					  |
			/*  G |					  | D
			/*	  |					  |
			/*	  |					  |
			/*	  |					  |
			/*	  ---------------------
			/*  F		    D		    E 
			/*******************************/

			

			point.onmousedown = e=>{
				
				if(e.which !=1 || !this.annotationManager.isDrawing) return;
				
				//点击坐标
				let ox = e.clientX;
				let oy = e.clientY;

				//逆转此次数奇数为已经逆转，偶数为正常，
				let idx = 0;
				let idy = 0;
				
				//原点坐标
				let tox = this.x;
				let toy = this.y;

				//原点对角坐标
				let hoy = this.y + this.height;
				let hox = this.x + this.width;

				let mousemove = e=>{
					if(!this.canDrap) return;
					if(e.which != 1) return;
					e.stopPropagation();

					if(this.shift && point._align == 'bottomRight'){
						
						let x = e.clientX;
						let y = e.clientY;

						let absy = Math.abs(y- toy);
						let absx = Math.abs(x- tox);
						let abs = Math.max(absy, absx);

						//右边
						if(x > tox){

							//下边
							if(y > toy){
								this.y = toy;
								this.x = tox;

							//上边
							}else{
								this.y = toy-(this.shift ? abs : absy);
								this.x = tox;
							}
						}

						//左边
						if(x < tox){

							//下边
							if(y > toy){
								this.x = tox-(this.shift ? abs : absx);
								this.y = toy;

							//上边
							}else{
								this.x = tox-(this.shift ? abs : absx);
								this.y = toy-(this.shift ? abs : absy);
							}
						}
						this.height = Math.max(absy, absx);
						this.width = Math.max(absy, absx)
						this.updateAll();
						return;
					}
					
					//差值
					let disx = e.clientX - ox;
					let disy = e.clientY - oy;
					ox = e.clientX;
					oy = e.clientY;

					if(affects.x){
						this.x += disx;
					}
					if(affects.y){
						this.y += disy;
					}
					if(affects.width){
						this.width += affects.width*disx;
					}
					if(affects.height){
						this.height += affects.height*disy;
					}

					//当负数时，启动逆转
					if(this.width < 0){

						//向右
						if(disx > 0){

							//实际原点x
							if(idx != 0){
								this.x = tox;
								this.rectTranslate[0] = 0;
								tox = this.x;
								this.width = e.clientX - this.x;
								this.updateAll();
							}else{
								this.x = hox;
								this.width = 0;
								this.rectTranslate[0] = 0;
								tox = this.x;
								this.updateAll();
							}
						//向左
						}else{
							this.width = tox - e.clientX;
							this.x = e.clientX;
							this.rectTranslate[0] = 0;
							this.updateAll();
						}
						
						idx++;
						affects.width = -affects.width;
						return;
					}


					if(this.height < 0 ){

						if(disy > 0){

							//实际原点y
							if(idy != 0){
								this.y = toy;
								this.rectTranslate[1] = 0;
								toy = this.y;
								this.height = e.clientY - this.y;
								this.updateAll();
							}else{
								this.y = hoy;
								this.height = 0;
								this.rectTranslate[1] = 0;
								toy = this.y;
								this.updateAll();
							}
						}else{
							this.height = toy - e.clientY;
							this.y = e.clientY;
							this.rectTranslate[1] = 0;
							this.updateAll();
						}

						idy++;
						affects.height = -affects.height;
						return;
						
					}

					//x,y轴已经逆转，需要启动偏移
					if(idx%2 == 1){
						this.rectTranslate[0] = this.rectTranslate[0]-affects.width*disx;
					}
					if(idy%2 == 1){
						this.rectTranslate[1] = this.rectTranslate[1]-affects.height*disy;
					}
					this.updateAll();
				}

				let mouseup = e=>{
					this.drapMaskRef.style['pointer-events'] = 'all';
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);

					//重新计算
					this.updateAll();
					this.canDrap = true;
				}
				
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
			
		}

		//更新遮罩位置
		updateDrapMask(pointerEvents){
			let styleObj = {
				position:'absolute',
				left:this.x+'px',
				top:this.y+'px',
				zIndex:100,
				width:this.width+'px',
				height:this.height+'px',
				display:'block',
				cursor:'move',
				pointerEvents:pointerEvents,
				transform:`translate(${this.rectTranslate[0]}px, ${this.rectTranslate[1]}px)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}

		//移动事件绑定
		bindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.rectTranslate[0]+disx}px, ${this.rectTranslate[1]+disy}px)`;
					this.rectTranslate = [this.rectTranslate[0]+disx, this.rectTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					this.updateAll();
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
		}

		//更新原点，偏移清0
		updateAll(){
			this.x += this.rectTranslate[0];
			this.y += this.rectTranslate[1];
			this.rectTranslate[0] = this.rectTranslate[1] = 0;
			this.svgRef.setAttrs(this);
			this.updateDrapMask();
			this.updateControllerPoints();
		}

		//创建遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);
			
			this['pointer-events'] = 'none';
			this.svgRef.setAttrs(this);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//创建控制点
			this.createControllerPoints();
			
			//绑定拖拽事件
			this.bindDrapEvent();


			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));

			this.preventDefault(this.drapMaskRef);
		}
		
		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.annotationManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;

			this.viewer.parentNode.style.userSelect = 'initial';
		}


	}

	//矩形类
	class Rectangle extends EventController{
		constructor(viewer, annotationManager){
			
			super(viewer, annotationManager);
			this.name = 'rectangle';
			this.viewer = viewer;
			this.annotationManager = annotationManager;


			this.size = BorderSize.middle;
			this.color = Color.red;

			this.initData = null;
			this.annotation = null;
			
		}
		
		/**
		 * 设置边框大小
		 * @param {BorderSize} size
		 */
		setSize(size){
			this.size = BorderSize[size];
		}

		/**
		 * 设置颜色
		 * @param {Color} color 
		 */
		setColor(color){
			this.color = Color[color];
		}

		createAttrs(){

			let _color = this.color;
			let _hoverColor = JSON.parse(JSON.stringify(this.color));
			_hoverColor[3] = 0.8;
			this.initData = {
				viewer:this.viewer,
				style:'stroke:rgba('+_color.toString()+'); fill:none; stroke-width:'+this.size,
				x:0,
				y:0,
				originx:0,
				originy:0,
				width:0,
				height:0,
				rectTranslate:[0, 0],
				svgRef:null,
				domRef:null,
				shift:false,
				canDrap:false,
				hoverStyle:'stroke:rgba('+_hoverColor.toString()+'); fill:none; stroke-width:'+this.size,
				'pointer-events':'all'
			}

			this.initData.rectTranslate = JSON.parse(JSON.stringify(this.initData.rectTranslate))
			return {...this.initData};
		}

		bindMouseDownEvent(e){
			let x = e.clientX;
			let y = e.clientY;
			this.annotation = this.createAttrs();
			this.bindShiftEvent();
			this.annotation.x = x;
			this.annotation.y = y;
			this.annotation.originx = x;
			this.annotation.originy = y;
		}
		
		//shift绑定
		bindShiftEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 16){
					this.annotation.shift = true;
				}
			});
			document.addEventListener('keyup', e=>{
				if(e.which == 16){
					this.annotation.shift = false;
				}
			});
		}

		bindMouseMoveEvent(e){
			let x = e.clientX;
			let y = e.clientY;
			let absy = Math.abs(y-this.annotation.originy);
			let absx = Math.abs(x-this.annotation.originx);
			let abs = Math.max(absy, absx);

			//右边
			if(x > this.annotation.originx){

				//下边
				if(y > this.annotation.originy){
					this.annotation.y = this.annotation.originy;
					this.annotation.x = this.annotation.originx;

				//上边
				}else{
					this.annotation.y = this.annotation.originy-(this.annotation.shift ? abs : absy);
					this.annotation.x = this.annotation.originx;
				}
			}

			//左边
			if(x < this.annotation.originx){

				//下边
				if(y > this.annotation.originy){
					this.annotation.x = this.annotation.originx-(this.annotation.shift ? abs : absx);
					this.annotation.y = this.annotation.originy;

				//上边
				}else{
					
					this.annotation.x = this.annotation.originx-(this.annotation.shift ? abs : absx);
					this.annotation.y = this.annotation.originy-(this.annotation.shift ? abs : absy);

				}
			}

			
			this.annotation.height = absy;
			this.annotation.width = absx;
			if(this.annotation.shift){
				this.annotation.height = Math.max(absy, absx);
				this.annotation.width = Math.max(absy, absx);
			}
			if(absy > 4 && absx > 4 && !this.annotation.svgRef){
				this.annotation.svgRef = new CreateTag('rect', this.annotation);
				this.annotation.domRef = this.annotation.svgRef.tag;
				this.viewer.querySelector('g').appendChild(this.annotation.svgRef.tag);
				return;
			}
			
			this.annotation.svgRef && this.annotation.svgRef.setAttrs(this.annotation);
		}

		bindMouseUpEvent(){
			if(!this.annotation.svgRef) return false;
			this.annotation.domRef.remove();
			this.annotation.domRef = null;
			this.annotation.svgRef = null;
			let annotation = new RectangleFactory({...this.annotation}, this.annotationManager);
			this.annotationManager.currentAnnotation = annotation
		}
	}

	
	//通过参数重新构造箭头
	class ArrowFactory extends AnnotationFactory{
		constructor(annotationProps, annotationManager){


			super(annotationManager.viewer);
			
			this.name = 'arrow';
			this.initData = JSON.parse(JSON.stringify(annotationProps.initData));
			this.hoverStyle = annotationProps.hoverStyle;
			this.style = annotationProps.style;
			this.points = JSON.parse(JSON.stringify(annotationProps.points));

			this.worldTranslate = JSON.parse(JSON.stringify(annotationProps.worldTranslate));
			this.arrowTranslate = JSON.parse(JSON.stringify(annotationProps.arrowTranslate));
			this.arrowLeftRotate = annotationProps.arrowLeftRotate;
			this.arrowRightRotate = annotationProps.arrowRightRotate;

			//箭头dom
			this.domRef = null;
			this.svgRef = null;

			//拖拽对象，非dom
			this.arrowOrigin = JSON.parse(JSON.stringify(annotationProps.arrowOrigin));

			this.ox = annotationProps.ox;//箭头起始点世界坐标x
			this.oy = annotationProps.oy;//箭头起始点世界坐标y
			this.dx = annotationProps.dx;//箭头终点世界坐标x
			this.dy = annotationProps.dy;//箭头终点世界坐标
			this.width = annotationProps.width;
			this.height = annotationProps.height;
			this.canDrap = annotationProps.canDrap;
			this.isDrawing = annotationProps.isDrawing;
			this['pointer-events'] = annotationProps['pointer-events'];




			this.annotationManager = annotationManager;
			this.viewer = annotationManager.viewer;
			this.create();
		}

		//创建
		create(){
			this.svgRef = new CreateTag('polygon', this);
			this.canDrap = false;

			//保存引用
			this.domRef = this.svgRef.tag;
			this.viewer.querySelector('g').appendChild(this.svgRef.tag);

			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();
			this.bindDirectionEvent();
			this.annotationManager.currentAnnotation = this;
		}

		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.style = this.hoverStyle;
			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.style = this.style;
			}
		}

		//点击箭头，出现控制点遮罩层
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.annotationManager.currentAnnotation = this;
				this.annotationManager.isDrawing = true;
				this.createDrapMask();
				e.stopPropagation();

				this.viewer.parentNode.style.userSelect = 'none';
			});
		}

		//方向调整
		bindDirectionEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 37){
					this.arrowTranslate[0] -= 1;
					this.updateAll();
				}
				if(e.which == 38){
					this.arrowTranslate[1] -= 1;
					this.updateAll();
				}
				if(e.which == 39){
					this.arrowTranslate[0] += 1;
					this.updateAll();
				}
				if(e.which == 40){
					this.arrowTranslate[1] += 1;
					this.updateAll();
				}
				
			});
		}

		updateAll(){
			this.worldTranslate[0] += this.arrowTranslate[0]; 
			this.worldTranslate[1] += this.arrowTranslate[1]; 
			this.arrowTranslate[0] = this.arrowTranslate[1] = 0; 
			this.svgRef.setAttrs(this);
			this.updateDrapMask('all');

		}


		//阻挡右键默认菜单
		preventDefault(){
			document.querySelector('svg').oncontextmenu = (e)=>{e.preventDefault()}
		}

		//遮罩随鼠标移动
		BindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.worldTranslate[0]}px, ${this.worldTranslate[1]}px) translate(${this.arrowTranslate[0]+disx}px, ${this.arrowTranslate[1]+disy}px) rotate(${this.arrowRightRotate}deg)`;
					this.arrowTranslate = [this.arrowTranslate[0]+disx, this.arrowTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					//保存移动偏差
					this.arrowTranslate[0] += disx;
					this.arrowTranslate[1] += disy;
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
			}
		}
		
		//给控制点绑定事件
		bindControllerPointEvent(point){

			/**
			 * 1. 确定左右点
			 * 2. 确定旋转基点
			 * 3. 移动后，修改设置 箭头， 遮罩的属性，并保存
			 */
			
			let rightPointMove = e=>{
				if(!this.canDrap) return;
				if(e.which != 1) return;
				e.stopPropagation();

				//辅助三角形旋转角的临边
				let x = e.clientX - (this.ox + this.arrowTranslate[0]) -10;

				//构成三角形旋转角的对边
				let y = e.clientY- (this.oy + this.arrowTranslate[1])-this.initData.initY-10;
				this.dx = e.clientX;
				this.dy = e.clientY;

				//勾股定理，这个就是旋转后的width
				let newX = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));

				//当长度小于最小值
				if(newX < this.initData.initX) newX = this.initData.initX;

				this.width = newX;

				//只修改x值，也就是修改长度
				this.points[3][0] = newX;
				this.points[1][0] = newX- this.initData.cornCDX;
				this.points[2][0] = newX- this.initData.cornABX;
				this.points[4][0] = newX- this.initData.cornABX;
				this.points[5][0] = newX- this.initData.cornCDX;

				
				//定义向量，求夹角		
				let newVector = [x, y];
				let oldVector = [this.ox, 0];

				let angle = angleVector2d(newVector, oldVector);
				let newRotate = angle*180/Math.PI;


				//自动吸附到0度
				if(newRotate < 2) newRotate = 0;
				
				//当鼠标移动到初始箭头上方时
				if(e.clientY < this.oy + this.arrowTranslate[1]){
					newRotate = 360 - newRotate;
				}


				//自动吸附
				if(newRotate < 182 && newRotate > 178) newRotate = 180;

				this.arrowRightRotate = newRotate;
				this.svgRef.setAttrs(this);
				this.updateDrapMask('none', `left center`);

				
			}

			point.onmousedown = e=>{
				if(e.which !=1 || !this.annotationManager.isDrawing) return;

				let mouseup = e=>{
					this.drapMaskRef.style['pointer-events'] = 'all';
					document.removeEventListener('mousemove', point._align == 'right' && rightPointMove || leftPointMove);
					document.removeEventListener('mouseup', mouseup);
					this.canDrap = true;
				}
				
				document.addEventListener('mousemove', point._align == 'right' && rightPointMove || leftPointMove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
			
		}


		//创建两个移动点
		createControllerPoints(drapMaskRef){
			let createPoint = (align)=>{
				let point = document.createElement('a');
				point.style.href= 'javascript:;';
				point.style.width = point.style.height = '10px';
				point.style.boxSizing = 'border-box';
				point.style.border = '2px solid red';
				point.style.background = '#fff';
				point.style.borderRadius = '10px';
				point.style.cursor = 'initial';
				point.style['pointer-events'] = 'all';
				point.style.position = 'absolute';
				point.style.top = '50%';
				point.style.marginTop = '-5px';
				point._align = align;
				align == 'left' && (point.style.left = '-5px') || (point.style.right = '-5px');
				return point;
			}
			let leftPoint = createPoint('left');
			let rightPoint = createPoint('right');
			rightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			this.bindControllerPointEvent(rightPoint);
			drapMaskRef.appendChild(rightPoint);
		}
		
		//更新遮罩位置
		updateDrapMask(pointerEvents, transformOrigin){
			transformOrigin = transformOrigin || 'left center';
			let styleObj = {
				position:'absolute',
				left:0,
				top:0,
				zIndex:100,
				width:this.width+'px',
				height:this.height+'px',
				display:'block',
				cursor:'move',
				pointerEvents:pointerEvents,
				transformOrigin:transformOrigin,
				transform:`translate(${this.worldTranslate[0]}px, ${this.worldTranslate[1]}px) translate(${this.arrowTranslate[0]}px, ${this.arrowTranslate[1]}px) rotate(${this.arrowRightRotate}deg) rotate(${this.arrowLeftRotate}deg)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}

		//创建遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//创建控制点
			this.createControllerPoints(this.drapMaskRef);
			
			//绑定拖拽事件
			this.BindDrapEvent();


			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));

			this.preventDefault(this.drapMaskRef);
		}
		
		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.annotationManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;

			this.viewer.parentNode.style.userSelect = 'initial';
		}
	}
	

	
	//绘制箭头
	class Arrow extends EventController{
		constructor(viewer, annotationManager){
			super(viewer, annotationManager);
			this.annotationManager = annotationManager;

			this.name = 'arrow';

			/********************************/
			/*	        	  A	 			*/	
			/*			  	  | C 			*/
			/*	O1		  		|			*/
			/*	O----------------|-----X 	*/			  		
			/*	02		  		|			*/
			/*			  	  | D			*/
			/*	          	  B				*/
			/********************************/


			this.initY = ArrowSize.large;

			this.color = Color.red;

			

			
			this.annotation = null;
		}
		
		/**
		 * 设置大小
		 * @param {ArrowSize} size
		 */
		setSize(size){
			this.initY = ArrowSize[size];
		}
		
		/**
		 * 设置颜色
		 * @param {Color} color 
		 */
		setColor(color){
			this.color = Color[color];
		}
		
		//初始化属性
		createAttrs(){
			let initX = 16;//固定
			let initH = this.initY*2;
			let cornABX = this.initY+2;
			let cornCDX = this.initY-2;	
			let PO1 = [0, this.initY-1];
			let PO2 = [0, this.initY+1];
			let PX = [initX, this.initY];
			let PA = [initX-cornABX, 0];
			let PB = [initX-cornABX, initH];
			let PC = [initX-cornCDX, 7];
			let PD = [initX-cornCDX, initH-7];
			let initPoints = [PO1, PC, PA, PX, PB, PD, PO2];
			let initWorldTranslate = [0, 0];
			let initArrowTranslate = [0, 0];
			let initArrowOrigin = [0, this.initY];


			this.initData = {
				initX:initX,
				initY:this.initY,
				cornABX:cornABX,
				cornCDX:cornCDX,
				points:initPoints,
				worldTranslate:initWorldTranslate,
				arrowTranslate:initArrowTranslate,
				arrowOrigin:initArrowOrigin,
				width:initX,
				height:initH,
			}
			let _color = this.color;
			let _hoverColor = JSON.parse(JSON.stringify(this.color));
			_hoverColor[3] = 0.8;
			return {
				viewer:this.viewer,
				initData:JSON.parse(JSON.stringify(this.initData)),
				hoverStyle:'fill:rgba('+_hoverColor.toString()+')',
				style:'fill:rgba('+_color.toString()+')',
				points:JSON.parse(JSON.stringify(this.initData.points)),
				// points:[[0, 9], [16, 7], [4,0], [16, 10], [4,20], [16, 20-7], [0, 11]],
				//世界坐标移动
				worldTranslate:JSON.parse(JSON.stringify(this.initData.worldTranslate)),

				//模型坐标移动
				arrowTranslate:JSON.parse(JSON.stringify(this.initData.arrowTranslate)),

				arrowLeftRotate:360,
				arrowRightRotate:360,

				//箭头dom
				domRef:null,

				//CreateTag
				svgRef:null,

				//拖拽对象，非dom
				arrowOrigin:JSON.parse(JSON.stringify(this.initData.arrowOrigin)),
				ox:0,//箭头起始点世界坐标x
				oy:0,//箭头起始点世界坐标y
				dx:0,//箭头终点世界坐标x
				dy:0,//箭头终点世界坐标
				width:this.initData.width,
				height:this.initData.height,
				canDrap:false,
				isDrawing:false,
				'pointer-events':"inherit"
			}
		}
		
		//绘制按下鼠标左键
		bindMouseDownEvent(e){
			this.annotation = this.createAttrs();
			this.annotation.ox = e.clientX;
			this.annotation.oy = e.clientY- this.initData.initY;
			this.annotation.worldTranslate = [this.annotation.ox, this.annotation.oy];
		}
		
		
		//绘制按下鼠标左键后移动
		bindMouseMoveEvent(e){
			let x = e.clientX - this.annotation.ox - this.initData.initX/2;
			let y = e.clientY- this.annotation.oy - this.initData.initY*2;

			this.annotation.dx = e.clientX;
			this.annotation.dy = e.clientY;

			//勾股定理
			let newX = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
			
			//当长度小于最小值
			if(newX > this.initData.initX && !this.annotation.svgRef){
				this.annotation.svgRef = new CreateTag('polygon', this.annotation);

				this.annotation.canDrap = false;

				//保存引用
				this.annotation.domRef = this.annotation.svgRef.tag;
				this.viewer.querySelector('g').appendChild(this.annotation.svgRef.tag);
			}

			if(newX < this.initData.initX) newX = this.initData.initX;

			

			this.annotation.width = newX;

			//只修改x值，也就是修改长度
			this.annotation.points[3][0] = newX;
			this.annotation.points[1][0] = newX-this.initData.cornCDX;
			this.annotation.points[2][0] = newX-this.initData.cornABX;
			this.annotation.points[4][0] = newX-this.initData.cornABX;
			this.annotation.points[5][0] = newX-this.initData.cornCDX;

			
			//定义向量，求夹角		
			let newVector = [x, y];
			let oldVector = [this.annotation.ox, 0];

			let angle = angleVector2d(newVector, oldVector);
			let newRotate = angle*180/Math.PI;
			
			//自动吸附到0度
			if(newRotate < 2) newRotate = 0;
			
			//当鼠标移动到初始箭头上方时
			if(e.clientY < this.annotation.oy + this.annotation.arrowTranslate[1]){
				newRotate = 360 - newRotate;
			}

			//自动吸附
			if(newRotate < 182 && newRotate > 178) newRotate = 180;
			
			this.annotation.arrowRightRotate = newRotate;
			this.annotation.svgRef && this.annotation.svgRef.setAttrs(this.annotation);
		}
		
		//释放鼠标左键
		bindMouseUpEvent(e){
			if(!this.annotation.svgRef) return false;
			this.annotation.domRef.remove();
			this.annotation.domRef = null;
			this.annotation.svgRef = null;
			let annotation = new ArrowFactory({...this.annotation}, this.annotationManager);
			this.annotationManager.currentAnnotation = annotation;
		}

	}


	AnnotationManager.TextFactory = TextFactory;
	AnnotationManager.PathFactory = PathFactory;
	AnnotationManager.EllipseFactory = EllipseFactory;
	AnnotationManager.RectangleFactory = RectangleFactory;
	AnnotationManager.ArrowFactory = ArrowFactory;
	window.AnnotationManager = AnnotationManager;
	window.annotationManager = new AnnotationManager(svg);
	window.annotationManager.createAnnotationTools();

	let tools = [window.annotationManager.text, window.annotationManager.path, window.annotationManager.ellipse, window.annotationManager.rectangle, window.annotationManager.arrow];
	
	let setTool = tool=>{
		document.getElementById(tool.name).onclick =()=>{
			if(tool.isRunning){
				return tool.stop();
			}
			for(let _tool of tools){
				_tool.stop();
			}
			tool.start();
		};
	}
	for(let tool of tools){
		setTool(tool);
	}

	document.getElementById('clear').onclick = ()=>{
		annotationManager.clear();
	}
	
	let setSize = size=>{
		document.getElementById(size).onclick =()=>{
			for(let tool of tools){
				tool.setSize(size);
			}
		}
	}


	let setColor = color=>{
		document.getElementById(color).onclick =()=>{
			for(let tool of tools){
				tool.setColor(color);
			}
		}
	}


	setSize('small')
	setSize('middle')
	setSize('large')


	setColor('red')
	setColor('yellow')
	setColor('blue')
	setColor('green')
	setColor('black')
	setColor('white')


	
</script>
