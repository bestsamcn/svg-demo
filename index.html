<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>all in one</title>
<script>

	//求2d向量夹角
	var angleVector2d = (a, b)=>{
	  let x1 = a[0],
	    y1 = a[1],
	    x2 = b[0],
	    y2 = b[1];
	  
	  let len1 = x1*x1 + y1*y1;
	  if (len1 > 0) {
	    len1 = 1 / Math.sqrt(len1);
	  }
	  
	  let len2 = x2*x2 + y2*y2;
	  if (len2 > 0) {
	    len2 = 1 / Math.sqrt(len2);
	  }
	  
	  let cosine = (x1 * x2 + y1 * y2) * len1 * len2;
	  
	  
	  if(cosine > 1.0) {
	    return 0;
	  }
	  else if(cosine < -1.0) {
	    return Math.PI;
	  } else {
	    return Math.acos(cosine);
	  }
	}
</script>
<meta name="keywords" content="">
<link hdomRef="" rel="stylesheet">
<style>
	.svg svg, .svg line:hover , .svg path:hover, .svg polygon:hover, .svg rect:hover, .svg circle:hover, .svg ellipse:hover{
		pointer-events: all;
	}
</style>
</head>
<body>
    <div class="svg" style="width:600px; height:600px;border:1px solid #333; position: relative;">
    	<svg pointer-events="painted" width="600" height="600" id="svg" style="position:absolute; left:0px; top:0px;">
    		<g id="ggg" pointer-events="inherit"></g>

    	</svg>
    	<div style="position: absolute;left:0;top:0; width:100%; height:100%; pointer-events:none;" class="svg-hover"></div>
    	<div style="width:100%;height:1px;left:0; top:50%;background: #333;position: absolute; pointer-events: none"></div>
    	<div style="width:1px;height:100%;left:50%; top:0%;background: #333;position: absolute; pointer-events: none"></div>
    </div>
</body>
</html>
<script>
	let svg = document.querySelector('#svg');
	let svgg = svg.querySelector('g');

	class CreateSVG{
		constructor(tag, attrs){
			this.tag = document.createElementNS('http://www.w3.org/2000/svg', tag);
			this.attrs = attrs;
			this.setAttrs(attrs);
		}

		/**
		 * 设置属性对象
		 * @param {Object} attrs 属性名
		 */
		setAttrs(attrs){
			for(let attr in attrs){
				
				
				//矩形
				if(attr == 'rectTranslate'){
					this.tag.setAttribute('transform', `translate(${attrs[attr].join(' ').toString()})`);	
					continue;
				}

				
				//箭头
				if(attr == 'domRef' || attr == 'polygon') continue;
				if(attr == 'points' || attr == 'rectTranslate'){
					this.tag.setAttribute(attr, attrs[attr].join(' ').toString());	
					continue;
				}
				if(attr == 'worldTranslate' || attr == 'arrowTranslate' || attr == 'arrowRightRotate' || attr == 'arrowLeftRotate'){
					let _attrs = `translate(${attrs.worldTranslate.toString()}) translate(${attrs.arrowTranslate.toString()}) rotate(${attrs.arrowRightRotate}, ${0}, ${10}) rotate(${attrs.arrowLeftRotate}, ${attrs.width}, ${10})`;
					this.tag.setAttribute('transform', _attrs);
					continue;
				}
				if((attr == 'width' || attr == 'height') && attrs[attr] < 0 ) return;
				this.tag.setAttribute(attr, attrs[attr]);
	        }
		}
	}

	
	//图形管理类
	class PrimitiveManager {
		constructor(){
			this.primitives = [];
			this._currentPrimitive = null;
			this.isDrawing = false;

		}

		get currentPrimitive(){
			return this._currentPrimitive;
		}
		set currentPrimitive(_primitive){
			for(let primitive of this.primitives){
				this.isDrawing = false;

				//恢复原始状态
				primitive.canDrap = false;
				primitive['pointer-events'] = 'all';
				primitive.svgRef.setAttrs(primitive);
				primitive.drapMaskRef && (primitive.drapMaskRef.style.display='none');
				primitive.domRef.style = primitive.style;
			}
			if(!!_primitive){
				_primitive.canDrap = true;
			}
			this._currentPrimitive = _primitive;
		}
	}

	
	//事件控制类
	class EventController{
		constructor(viewer, primitiveManager){
			this.viewer = viewer;
			this.primitiveManager = primitiveManager;
			this.viewer.addEventListener('mousedown', this._bindMouseDownEvent.bind(this));
		}
		
		_bindMouseDownEvent(e){
			if(e.which !=1 ) return false;
			if(this.primitiveManager.isDrawing) return;
			this.primitiveManager.isDrawing = true;
			this.bindMouseDownEvent && this.bindMouseDownEvent(e);

			
			let bindMouseMoveEvent = (e)=>{
				if(e.which !=1 ) return false;
				if(!this.primitiveManager.isDrawing) return;
				this.bindMouseMoveEvent && this.bindMouseMoveEvent(e);
			}

			let bindMouseUpEvent = (e)=>{
				if(e.which !=1 ) return false;
				this.primitiveManager.isDrawing = false;
				this.bindMouseUpEvent && this.bindMouseUpEvent(e);

				document.removeEventListener('mousemove', bindMouseMoveEvent);
				document.removeEventListener('mouseup', bindMouseUpEvent);
			}
			
			document.addEventListener('mousemove', bindMouseMoveEvent);
			document.addEventListener('mouseup', bindMouseUpEvent);
		}
		bindMouseDownEvent(e){}
		bindMouseMoveEvent(e){}
		bindMouseUpEvent(e){}
	}

	class RectangleFactory{
		constructor(primitiveProps, primitiveManager){
			this.type = 'rectancle';
			this.viewer = primitiveProps.viewer;
			this.style = primitiveProps.style;
			this.hoverStyle = primitiveProps.hoverStyle;
			this.x = primitiveProps.x;
			this.y = primitiveProps.y;
			this.originx = primitiveProps.originx;
			this.originy = primitiveProps.originy;
			this.width = primitiveProps.width;
			this.height = primitiveProps.height;
			this.rectTranslate = primitiveProps.rectTranslate;
			this.svgRef =null;
			this.domRef =null;
			this.drapMaskRef = null;
			this.canDrap = false;
			this.shift = primitiveProps.shift;
			this['pointer-events'] = primitiveProps['pointer-events'];
			
			this.primitiveManager = primitiveManager;

			this.controllerPoints = [];
			

			this.create();
		}

		create(){
			this.svgRef = new CreateSVG('rect', this);
			this.domRef = this.svgRef.tag;
			this.viewer.querySelector('g').appendChild(this.svgRef.tag);
			
			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();
			this.bindShiftEvent();
		}

		//shift绑定
		bindShiftEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 16){
					this.shift = true;
				}
			});
			document.addEventListener('keyup', e=>{
				if(e.which == 16){
					this.shift = false;
				}
			});
		}

		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.style = this.hoverStyle;

			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.style = this.style;
			}
		}

		//绑定事件
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.primitiveManager.currentPrimitive = this;
				this.primitiveManager.isDrawing = true;
				this.createDrapMask();
				e.stopPropagation();
			});
		}

		//阻挡右键默认菜单
		preventDefault(){
			document.querySelector('svg').oncontextmenu = (e)=>{e.preventDefault()}
		}
		
		//更新控制点，一把梭
		updateControllerPoints(){
			for(let point of this.controllerPoints){
				point.remove();
			}
			this.createControllerPoints();
		}

		//创建控制点
		createControllerPoints(){

			/**
			 * 创建控制点
			 * @param  {String} options.left    左偏移
			 * @param  {String} options.top     上偏移
			 * @param  {String} options.cursor  鼠标类型
			 * @param  {String} options.align   位置，只做别名，无其他作用
			 * @param  {String} options.affects 影响范围，0-无影响，1-正相关， -1-负相关
			 * @return {String}                 [description]
			 */
			let createPoint = ({left, top, cursor, align, affects})=>{
				let point = document.createElement('a');
				point.style.href= 'javascript:;';
				point.style.width = point.style.height = '10px';
				point.style.border = '2px solid red';
				point.style.boxSizing = 'border-box';
				point.style.background = '#fff';
				point.style.borderRadius = '5px';
				point.style.cursor = cursor;
				point.style['pointer-events'] = 'all';
				point.style.position = 'absolute';
				point.style.left = left;
				point.style.top = top;
				point._align = align;
				point.affects= affects;
				return point;
			}
			
			let topLeftPoint = createPoint({left:'-5px', top:'-5px', cursor:'nwse-resize', align:'topLeft', affects:{x:1, y:1, width:-1, height:-1}});
			let topCenterPoint = createPoint({left:'calc(50% - 5px)', cursor:'s-resize', top:'-5px', align:'topCenter', affects:{x:0, y:1, width:0, height:-1}});
			let topRightPoint = createPoint({left:'calc(100% - 5px)', cursor:'nesw-resize', top:'-5px', align:'topRight', affects:{x:0, y:1, width:1, height:-1}});
			let middleLeftPoint = createPoint({left:'-5px', top:'calc(50% - 5px)', cursor:'e-resize', align:'middleLeft', affects:{x:1, y:0, width:-1, height:0}});
			let middleRightPoint = createPoint({left:'calc(100% - 5px)', top:'calc(50% - 5px)', cursor:'w-resize', align:'middleRight', affects:{x:0, y:0, width:1, height:0}});
			let bottomLeftPoint = createPoint({left:'-5px', top:'calc(100% - 5px)', cursor:'nesw-resize', align:'bottomLeft', affects:{x:1, y:0, width:-1, height:1}});
			let bottomCenterPoint = createPoint({left:'calc(50% - 5px)', top:'calc(100% - 5px)', cursor:'n-resize', align:'bottomCenter', affects:{x:0, y:0, width:0, height:1}});
			let bottomRightPoint = createPoint({left:'calc(100% - 5px)', top:'calc(100% - 5px)', cursor:'nwse-resize', align:'bottomRight', affects:{x:0, y:0, width:1, height:1}});
			topLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			topCenterPoint.oncontextmenu = (e)=>{e.preventDefault()}
			topRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			middleLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			middleRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomLeftPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomCenterPoint.oncontextmenu = (e)=>{e.preventDefault()}
			bottomRightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			this.bindControllerPointEvent(topLeftPoint);
			this.bindControllerPointEvent(topCenterPoint);
			this.bindControllerPointEvent(topRightPoint);
			this.bindControllerPointEvent(middleLeftPoint);
			this.bindControllerPointEvent(middleRightPoint);
			this.bindControllerPointEvent(bottomLeftPoint);
			this.bindControllerPointEvent(bottomCenterPoint);
			this.bindControllerPointEvent(bottomRightPoint);
			this.drapMaskRef.appendChild(topLeftPoint);
			this.drapMaskRef.appendChild(topCenterPoint);
			this.drapMaskRef.appendChild(topRightPoint);
			this.drapMaskRef.appendChild(middleLeftPoint);
			this.drapMaskRef.appendChild(middleRightPoint);
			this.drapMaskRef.appendChild(bottomLeftPoint);
			this.drapMaskRef.appendChild(bottomCenterPoint);
			this.drapMaskRef.appendChild(bottomRightPoint);
			this.controllerPoints = [topLeftPoint, topRightPoint, middleLeftPoint, middleLeftPoint, bottomLeftPoint, bottomCenterPoint, bottomRightPoint];
		}

		//给控制点绑定事件
		bindControllerPointEvent(point){

			let affects = point.affects;


			/*******************************/	
			/*   A          B           C
			/*	  ---------------------
			/*	  |					  |				
			/*	  |                   |
			/*	  |					  |
			/*  G |					  | D
			/*	  |					  |
			/*	  |					  |
			/*	  |					  |
			/*	  ---------------------
			/*  F		    D		    E 
			/*******************************/

			

			point.onmousedown = e=>{
				
				if(e.which !=1 || !this.primitiveManager.isDrawing) return;
				
				//点击坐标
				let ox = e.clientX;
				let oy = e.clientY;

				//逆转此次数奇数为已经逆转，偶数为正常，
				let idx = 0;
				let idy = 0;
				
				//原点坐标
				let tox = this.x;
				let toy = this.y;

				//原点对角坐标
				let hoy = this.y + this.height;
				let hox = this.x + this.width;

				let mousemove = e=>{
					if(!this.canDrap) return;
					if(e.which != 1) return;
					e.stopPropagation();

					if(this.shift){
						
						let x = e.clientX;
						let y = e.clientY;

						let absy = Math.abs(y- toy);
						let absx = Math.abs(x- tox);
						let abs = Math.max(absy, absx);

						//右边
						if(x > tox){

							//下边
							if(y > toy){
								this.y = toy;
								this.x = tox;

							//上边
							}else{
								this.y = toy-(this.shift ? abs : absy);
								this.x = tox;
							}
						}

						//左边
						if(x < tox){

							//下边
							if(y > toy){
								this.x = tox-(this.shift ? abs : absx);
								this.y = toy;

							//上边
							}else{
								this.x = tox-(this.shift ? abs : absx);
								this.y = toy-(this.shift ? abs : absy);
							}
						}
						this.height = Math.max(absy, absx);
						this.width = Math.max(absy, absx)
						this.svgRef.setAttrs(this);
						this.updateDrapMask('none');
						return;
					}
					
					//差值
					let disx = e.clientX - ox;
					let disy = e.clientY - oy;
					ox = e.clientX;
					oy = e.clientY;

					if(affects.x){
						this.x += disx;
					}
					if(affects.y){
						this.y += disy;
					}
					if(affects.width){
						this.width += affects.width*disx;
					}
					if(affects.height){
						this.height += affects.height*disy;
					}

					//当负数时，启动逆转
					if(this.width < 0){

						//向右
						if(disx > 0){

							//实际原点x
							if(idx != 0){
								this.x = tox;
								this.rectTranslate[0] = 0;
								tox = this.x;
								this.width = e.clientX - this.x;
								this.updateAll();
							}else{
								this.x = hox;
								this.width = 0;
								this.rectTranslate[0] = 0;
								tox = this.x;
								this.updateAll();
							}
						//向左
						}else{
							this.width = tox - e.clientX;
							this.x = e.clientX;
							this.rectTranslate[0] = 0;
							this.updateAll();
						}
						
						idx++;
						affects.width = -affects.width;
						return;
					}


					if(this.height < 0 ){

						if(disy > 0){

							//实际原点y
							if(idy != 0){
								this.y = toy;
								this.rectTranslate[1] = 0;
								toy = this.y;
								this.height = e.clientY - this.y;
								this.updateAll();
							}else{
								this.y = hoy;
								this.height = 0;
								this.rectTranslate[1] = 0;
								toy = this.y;
								this.updateAll();
							}
						}else{
							this.height = toy - e.clientY;
							this.y = e.clientY;
							this.rectTranslate[1] = 0;
							this.updateAll();
						}

						idy++;
						affects.height = -affects.height;
						return;
						
					}

					//x,y轴已经逆转，需要启动偏移
					if(idx%2 == 1){
						this.rectTranslate[0] = this.rectTranslate[0]-affects.width*disx;
					}
					if(idy%2 == 1){
						this.rectTranslate[1] = this.rectTranslate[1]-affects.height*disy;
					}
					this.updateAll();
				}

				let mouseup = e=>{
					this.drapMaskRef.style['pointer-events'] = 'all';
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);

					//重新计算
					this.updateAll();
					this.canDrap = true;
				}
				
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
			
		}

		//更新遮罩位置
		updateDrapMask(pointerEvents){
			let styleObj = {
				position:'absolute',
				left:this.x+'px',
				top:this.y+'px',
				zIndex:100,
				width:this.width+'px',
				height:this.height+'px',
				display:'block',
				cursor:'move',
				pointerEvents:pointerEvents,
				transform:`translate(${this.rectTranslate[0]}px, ${this.rectTranslate[1]}px)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}

		//移动事件绑定
		bindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.rectTranslate[0]+disx}px, ${this.rectTranslate[1]+disy}px)`;
					this.rectTranslate = [this.rectTranslate[0]+disx, this.rectTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					this.updateAll();
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
		}

		//更新原点，偏移清0
		updateAll(){
			this.x += this.rectTranslate[0];
			this.y += this.rectTranslate[1];
			this.rectTranslate[0] = this.rectTranslate[1] = 0;
			this.svgRef.setAttrs(this);
			this.updateDrapMask();
			this.updateControllerPoints();
		}

		//创建遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);
			
			this['pointer-events'] = 'none';
			this.svgRef.setAttrs(this);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//创建控制点
			this.createControllerPoints();
			
			//绑定拖拽事件
			this.bindDrapEvent();


			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));
		}
		
		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.primitiveManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;
		}


	}

	//矩形类
	class Rectangle extends EventController{
		constructor(viewer, primitiveManager){
			super(viewer, primitiveManager);
			this.viewer = viewer;
			this.primitiveManager = primitiveManager;
			this.initData = {
				viewer:this.viewer,
				style:'stroke:red; fill:none; stroke-width:5',
				x:0,
				y:0,
				originx:0,
				originy:0,
				width:0,
				height:0,
				rectTranslate:[0, 0],
				svgRef:null,
				domRef:null,
				shift:false,
				canDrap:false,
				hoverStyle:'stroke:green; fill:none; stroke-width:5',
				'pointer-events':'all'
			}

			this.primitive = null;
			this.bindShiftEvent();
		}

		createAttrs(){
			this.initData.rectTranslate = JSON.parse(JSON.stringify(this.initData.rectTranslate))
			return {...this.initData};
		}

		bindMouseDownEvent(e){
			let x = e.clientX;
			let y = e.clientY;
			this.primitive = this.createAttrs();
			this.primitive.x = x;
			this.primitive.y = y;
			this.primitive.originx = x;
			this.primitive.originy = y;
		}
		
		//shift绑定
		bindShiftEvent(){
			document.addEventListener('keydown', e=>{
				if(e.which == 16){
					this.primitive.shift = true;
				}
			});
			document.addEventListener('keyup', e=>{
				if(e.which == 16){
					this.primitive.shift = false;
				}
			});
		}

		bindMouseMoveEvent(e){
			let x = e.clientX;
			let y = e.clientY;
			let absy = Math.abs(y-this.primitive.originy);
			let absx = Math.abs(x-this.primitive.originx);
			let abs = Math.max(absy, absx);

			//右边
			if(x > this.primitive.originx){

				//下边
				if(y > this.primitive.originy){
					this.primitive.y = this.primitive.originy;
					this.primitive.x = this.primitive.originx;

				//上边
				}else{
					this.primitive.y = this.primitive.originy-(this.primitive.shift ? abs : absy);
					this.primitive.x = this.primitive.originx;
				}
			}

			//左边
			if(x < this.primitive.originx){

				//下边
				if(y > this.primitive.originy){
					this.primitive.x = this.primitive.originx-(this.primitive.shift ? abs : absx);
					this.primitive.y = this.primitive.originy;

				//上边
				}else{
					
					this.primitive.x = this.primitive.originx-(this.primitive.shift ? abs : absx);
					this.primitive.y = this.primitive.originy-(this.primitive.shift ? abs : absy);

				}
			}

			
			this.primitive.height = absy;
			this.primitive.width = absx;
			if(this.primitive.shift){
				this.primitive.height = Math.max(absy, absx);
				this.primitive.width = Math.max(absy, absx);
			}
			if(absy > 4 && absx > 4 && !this.primitive.svgRef){
				this.primitive.svgRef = new CreateSVG('rect', this.primitive);
				this.primitive.domRef = this.primitive.svgRef.tag;
				this.viewer.querySelector('g').appendChild(this.primitive.svgRef.tag);
				return;
			}
			
			this.primitive.svgRef && this.primitive.svgRef.setAttrs(this.primitive);
		}

		bindMouseUpEvent(){
			if(!this.primitive.svgRef) return false;
			this.primitive.domRef.remove();
			this.primitive.domRef = null;
			this.primitive.svgRef = null;
			let primitive = new RectangleFactory({...this.primitive}, primitiveManager);
			primitiveManager.primitives.push(primitive);
			primitiveManager.currentPrimitive = primitive
		}
	}

	
	//通过参数重新构造箭头
	class PolygoneArrowFactory{
		constructor(primitiveProps, primitiveManager){
			
			this.type = 'polygonArrow';
			this.initData = JSON.parse(JSON.stringify(primitiveProps.initData));
			this.hoverStyle = primitiveProps.hoverStyle;
			this.style = primitiveProps.style;
			this.points = JSON.parse(JSON.stringify(primitiveProps.points));

			this.worldTranslate = JSON.parse(JSON.stringify(primitiveProps.worldTranslate));
			this.arrowTranslate = JSON.parse(JSON.stringify(primitiveProps.arrowTranslate));
			this.arrowLeftRotate = primitiveProps.arrowLeftRotate;
			this.arrowRightRotate = primitiveProps.arrowRightRotate;

			//箭头dom
			this.domRef = null;
			this.svgRef = null;

			//拖拽对象，非dom
			this.arrowOrigin = JSON.parse(JSON.stringify(primitiveProps.arrowOrigin));
			this.ox = primitiveProps.ox;//箭头起始点世界坐标x
			this.oy = primitiveProps.oy;//箭头起始点世界坐标y
			this.dx = primitiveProps.dx;//箭头终点世界坐标x
			this.dy = primitiveProps.dy;//箭头终点世界坐标
			this.width = primitiveProps.width;
			this.height = primitiveProps.height;
			this.canDrap = primitiveProps.canDrap;
			this.isDrawing = primitiveProps.isDrawing;
			this['pointer-events'] = primitiveProps['pointer-events'];




			this.primitiveManager = primitiveManager;
			this.viewer = primitiveProps.viewer;
			this.create();
		}

		//创建
		create(){
			this.svgRef = new CreateSVG('polygon', this);
			this.canDrap = false;

			//保存引用
			this.domRef = this.svgRef.tag;
			this.viewer.querySelector('g').appendChild(this.svgRef.tag);

			this.bindHoverEvent();
			this.bindClickEvent();
			this.preventDefault();
		}

		//绑定hover事件
		bindHoverEvent(){
			this.domRef.onmouseenter = ()=>{
				this.domRef.style = this.hoverStyle;
			}
			this.domRef.onmouseleave = ()=>{
				this.domRef.style = this.style;
			}
		}

		//点击箭头，出现控制点遮罩层
		bindClickEvent(){
			this.domRef.addEventListener('mousedown', e=>{
				if(e.which != 1) return;
				this.primitiveManager.currentPrimitive = this;
				this.primitiveManager.isDrawing = true;
				this.createDrapMask();
				e.stopPropagation();
			});
		}


		//阻挡右键默认菜单
		preventDefault(){
			document.querySelector('svg').oncontextmenu = (e)=>{e.preventDefault()}
		}

		//遮罩随鼠标移动
		BindDrapEvent(){
			this.drapMaskRef.onmousedown = e=>{
				if(!this.canDrap) return;
				let x = e.clientX;
				let y = e.clientY;
				let disx = 0;
				let disy = 0;
				let mousemove = e=>{
					disx = e.clientX - x;
					disy = e.clientY - y;
					x = e.clientX;
					y = e.clientY;

					//箭头和遮罩移动一致
					this.drapMaskRef.style.transform = `translate(${this.worldTranslate[0]}px, ${this.worldTranslate[1]}px) translate(${this.arrowTranslate[0]+disx}px, ${this.arrowTranslate[1]+disy}px) rotate(${this.arrowRightRotate}deg)`;
					this.arrowTranslate = [this.arrowTranslate[0]+disx, this.arrowTranslate[1]+disy];
					this.svgRef.setAttrs(this);
				}

				let mouseup= e=>{

					//保存移动偏差
					this.arrowTranslate[0] += disx;
					this.arrowTranslate[1] += disy;
					document.removeEventListener('mousemove', mousemove);
					document.removeEventListener('mouseup', mouseup);
				}
				document.addEventListener('mousemove', mousemove);
				document.addEventListener('mouseup', mouseup);
			}
		}
		
		//给控制点绑定事件
		bindControllerPointEvent(point){

			/**
			 * 1. 确定左右点
			 * 2. 确定旋转基点
			 * 3. 移动后，修改设置 箭头， 遮罩的属性，并保存
			 */
			
			let rightPointMove = e=>{
				if(!this.canDrap) return;
				if(e.which != 1) return;
				e.stopPropagation();

				//辅助三角形旋转角的临边
				let x = e.clientX - (this.ox + this.arrowTranslate[0]) -10;

				//构成三角形旋转角的对边
				let y = e.clientY- (this.oy + this.arrowTranslate[1])-this.initData.initY-10;
				this.dx = e.clientX;
				this.dy = e.clientY;

				//勾股定理，这个就是旋转后的width
				let newX = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));

				//当长度小于最小值
				if(newX < this.initData.initX) newX = this.initData.initX;

				this.width = newX;

				//只修改x值，也就是修改长度
				this.points[3][0] = newX;
				this.points[1][0] = newX- this.initData.cornCDX;
				this.points[2][0] = newX- this.initData.cornABX;
				this.points[4][0] = newX- this.initData.cornABX;
				this.points[5][0] = newX- this.initData.cornCDX;

				
				//定义向量，求夹角		
				let newVector = [x, y];
				let oldVector = [this.ox, 0];

				let angle = angleVector2d(newVector, oldVector);
				let newRotate = angle*180/Math.PI;


				//自动吸附到0度
				if(newRotate < 2) newRotate = 0;
				
				//当鼠标移动到初始箭头上方时
				if(e.clientY < this.oy + this.arrowTranslate[1]){
					newRotate = 360 - newRotate;
				}


				//自动吸附
				if(newRotate < 182 && newRotate > 178) newRotate = 180;

				this.arrowRightRotate = newRotate;
				this.svgRef.setAttrs(this);
				this.updateDrapMask('none', `left center`);

				
			}

			point.onmousedown = e=>{
				if(e.which !=1 || !this.primitiveManager.isDrawing) return;

				let mouseup = e=>{
					this.drapMaskRef.style['pointer-events'] = 'all';
					document.removeEventListener('mousemove', point._align == 'right' && rightPointMove || leftPointMove);
					document.removeEventListener('mouseup', mouseup);
					this.canDrap = true;
				}
				
				document.addEventListener('mousemove', point._align == 'right' && rightPointMove || leftPointMove);
				document.addEventListener('mouseup', mouseup);
				e.stopPropagation();
			}
			
		}


		//创建两个移动点
		createControllerPoints(drapMaskRef){
			let createPoint = (align)=>{
				let point = document.createElement('a');
				point.style.href= 'javascript:;';
				point.style.width = point.style.height = '10px';
				point.style.boxSizing = 'border-box';
				point.style.border = '2px solid red';
				point.style.background = '#fff';
				point.style.borderRadius = '10px';
				point.style.cursor = 'initial';
				point.style['pointer-events'] = 'all';
				point.style.position = 'absolute';
				point.style.top = '50%';
				point.style.marginTop = '-5px';
				point._align = align;
				align == 'left' && (point.style.left = '-5px') || (point.style.right = '-5px');
				return point;
			}
			let leftPoint = createPoint('left');
			let rightPoint = createPoint('right');
			rightPoint.oncontextmenu = (e)=>{e.preventDefault()}
			this.bindControllerPointEvent(rightPoint);
			drapMaskRef.appendChild(rightPoint);
		}
		
		//更新遮罩位置
		updateDrapMask(pointerEvents, transformOrigin){
			transformOrigin = transformOrigin || 'left center';
			let styleObj = {
				position:'absolute',
				left:0,
				top:0,
				zIndex:100,
				width:this.width+'px',
				height:this.height+'px',
				display:'block',
				cursor:'move',
				pointerEvents:pointerEvents,
				transformOrigin:transformOrigin,
				transform:`translate(${this.worldTranslate[0]}px, ${this.worldTranslate[1]}px) translate(${this.arrowTranslate[0]}px, ${this.arrowTranslate[1]}px) rotate(${this.arrowRightRotate}deg) rotate(${this.arrowLeftRotate}deg)`,
			}
			for(let i in styleObj) this.drapMaskRef.style[i] = styleObj[i];
		}

		//创建遮罩
		createDrapMask(){
			if(!this.canDrap) return;
			!this.drapMaskRef && (this.drapMaskRef = document.createElement('div')) & document.querySelector('.svg-hover').appendChild(this.drapMaskRef);

			this.updateDrapMask('all');
			document.querySelector('.svg-hover').style.display='block';
			this.domRef.style = this.style;
			
			//创建控制点
			this.createControllerPoints(this.drapMaskRef);
			
			//绑定拖拽事件
			this.BindDrapEvent();


			//点击右键遮罩
			document.addEventListener('mousedown', this.onDisppear.bind(this));
		}
		
		//消失
		onDisppear(e){
			if(e.which != 3) return;
			this.primitiveManager.isDrawing = false;
			this['pointer-events'] = 'inherit';
			this.svgRef.setAttrs(this);
			this.drapMaskRef && (this.drapMaskRef.style.display='none');
			this.drapMaskRef && this.drapMaskRef.remove();
			this.drapMaskRef = null;
			this.domRef.style = this.style;
		}
	}

	
	//绘制箭头
	class PolygonArrow extends EventController{
		constructor(viewer, primitiveManager){
			super(viewer, primitiveManager);
			this.primitiveManager = primitiveManager;

			/********************************/
			/*	        	  A	 			*/	
			/*			  	  | C 			*/
			/*	O1		  		|			*/
			/*	O----------------|-----X 	*/			  		
			/*	02		  		|			*/
			/*			  	  | D			*/
			/*	          	  B				*/
			/********************************/

			let initY = 10;
			let initX = 16;
			let initH = 20;
			let cornABX = 12;
			let cornCDX = 10;	
			let PO1 = [0, initY-1];
			let PO2 = [0, initY+1];
			let PX = [initX, initY];
			let PA = [initX-12, 0];
			let PB = [initX-12, initH];
			let PC = [initX-10, 7];
			let PD = [initX-10, initH-7];
			let initPoints = [PO1, PC, PA, PX, PB, PD, PO2];
			let initWorldTranslate = [0, 0];
			let initArrowTranslate = [0, 0];
			let initArrowOrigin = [0, initY];


			this.initData = {
				initX:initX,
				initY:initY,
				cornABX:cornABX,
				cornCDX:cornCDX,
				points:initPoints,
				worldTranslate:initWorldTranslate,
				arrowTranslate:initArrowTranslate,
				arrowOrigin:initArrowOrigin,
				width:initX,
				height:initH,
			}

			
			this.primitive = null;
		}
		
		//初始化属性
		createAttrs(){
			return {
				viewer:this.viewer,
				initData:JSON.parse(JSON.stringify(this.initData)),
				hoverStyle:'fill:green',
				style:'fill:red',
				points:JSON.parse(JSON.stringify(this.initData.points)),
				// points:[[0, 9], [16, 7], [4,0], [16, 10], [4,20], [16, 20-7], [0, 11]],
				//世界坐标移动
				worldTranslate:JSON.parse(JSON.stringify(this.initData.worldTranslate)),

				//模型坐标移动
				arrowTranslate:JSON.parse(JSON.stringify(this.initData.arrowTranslate)),
				arrowLeftRotate:360,
				arrowRightRotate:360,

				//箭头dom
				domRef:null,

				//CreateSVG
				svgRef:null,

				//拖拽对象，非dom
				arrowOrigin:JSON.parse(JSON.stringify(this.initData.arrowOrigin)),
				ox:0,//箭头起始点世界坐标x
				oy:0,//箭头起始点世界坐标y
				dx:0,//箭头终点世界坐标x
				dy:0,//箭头终点世界坐标
				width:this.initData.width,
				height:this.initData.height,
				canDrap:false,
				isDrawing:false,
				'pointer-events':"inherit"
			}
		}
		
		//绘制按下鼠标左键
		bindMouseDownEvent(e){
			this.primitive = this.createAttrs();
			this.primitive.ox = e.clientX;
			this.primitive.oy = e.clientY- this.initData.initY;
			this.primitive.worldTranslate = [this.primitive.ox, this.primitive.oy];
		}
		
		
		//绘制按下鼠标左键后移动
		bindMouseMoveEvent(e){
			let x = e.clientX - this.primitive.ox;
			let y = e.clientY- this.primitive.oy - this.initData.initY;

			this.primitive.dx = e.clientX;
			this.primitive.dy = e.clientY;

			//勾股定理
			let newX = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
			
			//当长度小于最小值
			if(newX > this.initData.initX && !this.primitive.svgRef){
				this.primitive.svgRef = new CreateSVG('polygon', this.primitive);

				this.primitive.canDrap = false;

				//保存引用
				this.primitive.domRef = this.primitive.svgRef.tag;
				this.viewer.querySelector('g').appendChild(this.primitive.svgRef.tag);
			}

			if(newX < this.initData.initX) newX = this.initData.initX;

			

			this.primitive.width = newX;

			//只修改x值，也就是修改长度
			this.primitive.points[3][0] = newX;
			this.primitive.points[1][0] = newX-this.initData.cornCDX;
			this.primitive.points[2][0] = newX-this.initData.cornABX;
			this.primitive.points[4][0] = newX-this.initData.cornABX;
			this.primitive.points[5][0] = newX-this.initData.cornCDX;

			
			//定义向量，求夹角		
			let newVector = [x, y];
			let oldVector = [this.primitive.ox, 0];

			let angle = angleVector2d(newVector, oldVector);
			let newRotate = angle*180/Math.PI;
			
			//自动吸附到0度
			if(newRotate < 2) newRotate = 0;
			
			//当鼠标移动到初始箭头上方时
			if(e.clientY < this.primitive.oy + this.primitive.arrowTranslate[1]){
				newRotate = 360 - newRotate;
			}

			//自动吸附
			if(newRotate < 182 && newRotate > 178) newRotate = 180;
			
			this.primitive.arrowRightRotate = newRotate;
			this.primitive.svgRef && this.primitive.svgRef.setAttrs(this.primitive);
		}
		
		//释放鼠标左键
		bindMouseUpEvent(e){
			if(!this.primitive.svgRef) return false;
			this.primitive.domRef.remove();
			this.primitive.domRef = null;
			this.primitive.svgRef = null;
			let primitive = new PolygoneArrowFactory({...this.primitive}, primitiveManager);
			primitiveManager.primitives.push(primitive);
			primitiveManager.currentPrimitive = primitive;
		}
	}
	window.primitiveManager = new PrimitiveManager();
	new Rectangle(svg, primitiveManager);
	// new PolygonArrow(svg, primitiveManager);

</script>
